diff --git a/b b/b
new file mode 120000
index 0000000..c297312
--- /dev/null
+++ b/b
@@ -0,0 +1 @@
+C:/users/zekew/_bazel_zekew/iqmh4g5r/external/docopt.cpp+
\ No newline at end of file
diff --git a/a/.gitignore b/a/.gitignore
deleted file mode 100644
index 6d7eb1c..0000000
--- a/a/.gitignore
+++ /dev/null
@@ -1,32 +0,0 @@
-# Compiled Object files
-*.slo
-*.lo
-*.o
-
-# Compiled Dynamic libraries
-*.so
-*.dylib
-*.dll
-
-# Compiled Static libraries
-*.lai
-*.la
-*.a
-
-# Compiled examples, as per docs
-example
-naval_fate
-run_testcase
-run_testcase.exe
-
-# CMake temporary files
-CMakeCache.txt
-CMakeFiles
-CPackConfig.cmake
-CPackSourceConfig.cmake
-Makefile
-cmake_install.cmake
-docopt-config-version.cmake
-
-# Files configured by CMake
-run_tests
diff --git a/a/.travis.yml b/a/.travis.yml
deleted file mode 100644
index 90e7c68..0000000
--- a/a/.travis.yml
+++ /dev/null
@@ -1,103 +0,0 @@
-language: cpp
-sudo: false   # Use the new container infrastructure
-
-matrix:
-  include:
-    - os: linux
-      env:
-        - COMPILER=g++-7
-      addons:
-        apt:
-          sources: ['ubuntu-toolchain-r-test']
-          packages: ["g++-7", "cmake-data", "cmake"]
-    - os: linux
-      env:
-        - COMPILER=g++-8
-      addons:
-        apt:
-          sources: ['ubuntu-toolchain-r-test']
-          packages: ["g++-8", "cmake-data", "cmake"]
-    - os: linux
-      env:
-        - COMPILER=g++-9
-      addons:
-        apt:
-          sources: ['ubuntu-toolchain-r-test']
-          packages: ["g++-9", "cmake-data", "cmake"]
-    - os: linux
-      env:
-        - COMPILER=g++-9 USE_BOOST_REGEX=ON
-      addons:
-        apt:
-          sources: ['ubuntu-toolchain-r-test']
-          packages: ["g++-9", "cmake-data", "cmake", "libboost-regex-dev"]
-
-    - os: linux
-      env:
-        - COMPILER=clang++-3.6 STDLIB=libc++
-      addons:
-        apt:
-          sources: ['ubuntu-toolchain-r-test', 'llvm-toolchain-precise-3.6', 'george-edison55-precise-backports']
-          packages: ["clang-3.6", "cmake-data", "cmake"]
-
-    - os: linux
-      env:
-        - COMPILER=clang++-8 STDLIB=libc++
-      addons:
-        apt:
-          sources: ['ubuntu-toolchain-r-test', 'llvm-toolchain-trusty-8']
-          packages: ["clang-8", "cmake-data", "cmake"]
-
-    - os: osx
-      osx_image: xcode9.4
-      env:
-        - COMPILER=clang++ V='Apple LLVM 9.1'
-        - COMPILER=clang++ V='Apple LLVM 9.1' WITH_CPP14=true
-
-    - os: osx
-      osx_image: xcode10.3
-      env:
-        - COMPILER=clang++ V='Apple LLVM 10.0'
-        - COMPILER=clang++ V='Apple LLVM 10.0' WITH_CPP14=true
-    - os: osx
-      osx_image: xcode11.2
-      env:
-        - COMPILER=clang++ V='Apple LLVM 11.0'
-        - COMPILER=clang++ V='Apple LLVM 11.0' WITH_CPP14=true
-    - os: osx
-      osx_image: xcode11.2
-      env:
-        - COMPILER=clang++ V='Apple LLVM 11.0'
-        - COMPILER=clang++ V='Apple LLVM 11.0' WITH_CPP17=true
-
-before_install:
-  - CMAKE_CXX_FLAGS+=" -Wall"
-  - |
-    if [[ "${WITH_CPP14}" == "true" ]]; then
-        CMAKE_OPTIONS+=" -DCMAKE_CXX_STANDARD=14"
-    fi
-  - |
-    if [[ "${WITH_CPP17}" == "true" ]]; then
-        CMAKE_OPTIONS+=" -DCMAKE_CXX_STANDARD=17"
-    fi
-  - |
-    if [[ "${USE_BOOST_REGEX}" == "ON" ]]; then
-        CMAKE_OPTIONS+=" -DUSE_BOOST_REGEX=ON"
-        CMAKE_OPTIONS+=" -DBoost_REGEX_LIBRARY_DEBUG=/usr/lib/x86_64-linux-gnu/libboost_regex.so"
-        CMAKE_OPTIONS+=" -DBoost_REGEX_LIBRARY_RELEASE=/usr/lib/x86_64-linux-gnu/libboost_regex.so"
-    fi
-  - |
-    if [[ "${STDLIB}" == "libc++" ]]; then
-        CMAKE_CXX_FLAGS+=" -stdlib=libc++"
-    fi
-  - ${COMPILER} --version
-
-before_script:
-  - rm -rf build/
-  - mkdir build
-  - cd build
-  - cmake -DCMAKE_CXX_COMPILER=${COMPILER} -DCMAKE_CXX_FLAGS=${CMAKE_CXX_FLAGS} -DWITH_TESTS=1 -DWITH_EXAMPLE=1 ${CMAKE_OPTIONS} ..
-
-script:
-  - cmake --build .
-  - python run_tests
diff --git a/a/BUILD.bazel b/a/BUILD.bazel
deleted file mode 100644
index 35ac77d..0000000
--- a/a/BUILD.bazel
+++ /dev/null
@@ -1,17 +0,0 @@
-load("@rules_cc//cc:defs.bzl", "cc_library")
-
-cc_library(
-    name = "docopt",
-    srcs = [
-        "docopt.cpp",
-        "docopt_private.h",
-    ],
-    hdrs = [
-        "docopt.h",
-        "docopt_util.h",
-        "docopt_value.h",
-    ],
-    defines = ["DOCTOPT_USE_BOOST_REGEX"],
-    visibility = ["//visibility:public"],
-    deps = ["@boost.regex"],
-)
diff --git a/a/CMakeLists.txt b/a/CMakeLists.txt
deleted file mode 100644
index 28da614..0000000
--- a/a/CMakeLists.txt
+++ /dev/null
@@ -1,129 +0,0 @@
-cmake_minimum_required(VERSION 3.1)
-project(docopt.cpp VERSION 0.6.2)
-
-include(GNUInstallDirs)
-
-#============================================================================
-# Settable options
-#============================================================================
-option(WITH_TESTS "Build tests." OFF)
-option(WITH_EXAMPLE "Build example." OFF)
-option(USE_BOOST_REGEX "Replace std::regex with Boost.Regex" OFF)
-
-#============================================================================
-# Internal compiler options
-#============================================================================
-# C++ standard
-set(CMAKE_CXX_STANDARD_REQUIRED ON)
-set(CMAKE_CXX_EXTENSIONS OFF)
-if(NOT CMAKE_CXX_STANDARD OR CMAKE_CXX_STANDARD LESS 11)
-	set(CMAKE_CXX_STANDARD 11)
-endif()
-
-#============================================================================
-# Sources & headers
-#============================================================================
-set(docopt_SOURCES docopt.cpp)
-set(docopt_HEADERS
-		docopt.h
-		docopt_private.h
-		docopt_util.h
-		docopt_value.h
-		)
-
-#============================================================================
-# Compile targets
-#============================================================================
-add_library(docopt ${docopt_SOURCES} ${docopt_HEADERS})
-set_target_properties(docopt PROPERTIES
-  VERSION ${PROJECT_VERSION}
-  SOVERSION ${PROJECT_VERSION_MAJOR}
-)
-
-target_include_directories(docopt PUBLIC $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}> $<INSTALL_INTERFACE:include/docopt>)
-
-if(MSVC AND BUILD_SHARED_LIBS)
-    # DOCOPT_DLL: Must be specified when building *and* when using the DLL.
-    #             That's what the "PUBLIC" means.
-    # DOCOPT_EXPORTS: Must use __declspec(dllexport) when building the DLL.
-    #                 "PRIVATE" means it's only defined when building the DLL.
-    target_compile_definitions(docopt PUBLIC  DOCOPT_DLL
-                                      PRIVATE DOCOPT_EXPORTS)
-endif()
-
-if(USE_BOOST_REGEX)
-	add_definitions("-DDOCTOPT_USE_BOOST_REGEX")
-	# This is needed on Linux, where linking a static library into docopt.so
-	# fails because boost static libs are not compiled with -fPIC
-	set(Boost_USE_STATIC_LIBS OFF)
-    find_package(Boost 1.53 REQUIRED COMPONENTS regex)
-    include_directories(${Boost_INCLUDE_DIRS})
-    target_link_libraries(docopt ${Boost_LIBRARIES})
-endif()
-
-#============================================================================
-# Examples
-#============================================================================
-if(WITH_EXAMPLE)
-	add_executable(docopt_example examples/naval_fate.cpp)
-	target_link_libraries(docopt_example docopt)
-endif()
-
-#============================================================================
-# Tests
-#============================================================================
-if(WITH_TESTS)
-	set(TESTPROG "${CMAKE_CURRENT_BINARY_DIR}/run_testcase")
-	set(TESTCASES "${PROJECT_SOURCE_DIR}/testcases.docopt")
-	add_executable(run_testcase run_testcase.cpp)
-	target_link_libraries(run_testcase docopt)
-	configure_file(
-			"${PROJECT_SOURCE_DIR}/run_tests.py"
-			"${CMAKE_CURRENT_BINARY_DIR}/run_tests"
-			ESCAPE_QUOTES
-	)
-	add_test("Testcases docopt" ${TESTPROG})
-endif()
-
-#============================================================================
-# Install
-#============================================================================
-set(export_name "docopt-targets")
-
-# Runtime package
-install(TARGETS docopt EXPORT ${export_name}
-	RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
-	ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
-	LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR})
-
-# Development package
-install(FILES ${docopt_HEADERS} DESTINATION include/docopt)
-
-# CMake Package
-include(CMakePackageConfigHelpers)
-write_basic_package_version_file("${PROJECT_BINARY_DIR}/docopt-config-version.cmake" COMPATIBILITY SameMajorVersion)
-install(FILES docopt-config.cmake ${PROJECT_BINARY_DIR}/docopt-config-version.cmake DESTINATION "${CMAKE_INSTALL_LIBDIR}/cmake/docopt")
-install(EXPORT ${export_name} DESTINATION "${CMAKE_INSTALL_LIBDIR}/cmake/docopt")
-
-configure_file(${CMAKE_CURRENT_SOURCE_DIR}/docopt.pc.in ${CMAKE_CURRENT_BINARY_DIR}/docopt.pc @ONLY)
-install(FILES ${CMAKE_CURRENT_BINARY_DIR}/docopt.pc DESTINATION ${CMAKE_INSTALL_LIBDIR}/pkgconfig)
-
-#============================================================================
-# CPack
-#============================================================================
-set(CPACK_PACKAGE_NAME "docopt")
-set(CPACK_DEBIAN_PACKAGE_DEPENDS "")
-set(CPACK_RPM_PACKAGE_REQUIRES "")
-set(CPACK_PACKAGE_DESCRIPTION_SUMMARY "Beautiful command line interfaces")
-set(CPACK_PACKAGE_VENDOR "Jared Grubb")
-set(CPACK_PACKAGE_CONTACT ${CPACK_PACKAGE_VENDOR})
-set(CPACK_PACKAGE_DESCRIPTION_FILE "${PROJECT_SOURCE_DIR}/README.rst")
-set(CPACK_RESOURCE_FILE_LICENSE "${PROJECT_SOURCE_DIR}/LICENSE-MIT")
-set(CPACK_PACKAGE_VERSION_MAJOR ${PROJECT_VERSION_MAJOR})
-set(CPACK_PACKAGE_VERSION_MINOR ${PROJECT_VERSION_MINOR})
-set(CPACK_PACKAGE_VERSION_PATCH ${PROJECT_VERSION_PATCH})
-set(CPACK_DEBIAN_PACKAGE_SECTION "Development")
-set(CPACK_RPM_PACKAGE_GROUP "Development/Libraries")
-set(CPACK_RPM_PACKAGE_LICENSE "MIT")
-set(CPACK_STRIP_FILES TRUE)
-include(CPack)
diff --git a/a/LICENSE-Boost-1.0 b/a/LICENSE-Boost-1.0
deleted file mode 100644
index 36b7cd9..0000000
--- a/a/LICENSE-Boost-1.0
+++ /dev/null
@@ -1,23 +0,0 @@
-Boost Software License - Version 1.0 - August 17th, 2003
-
-Permission is hereby granted, free of charge, to any person or organization
-obtaining a copy of the software and accompanying documentation covered by
-this license (the "Software") to use, reproduce, display, distribute,
-execute, and transmit the Software, and to prepare derivative works of the
-Software, and to permit third-parties to whom the Software is furnished to
-do so, all subject to the following:
-
-The copyright notices in the Software and this entire statement, including
-the above license grant, this restriction and the following disclaimer,
-must be included in all copies of the Software, in whole or in part, and
-all derivative works of the Software, unless such copies or derivative
-works are solely in the form of machine-executable object code generated by
-a source language processor.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
-SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
-FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
-ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
-DEALINGS IN THE SOFTWARE.
diff --git a/a/LICENSE-MIT b/a/LICENSE-MIT
deleted file mode 100644
index 58ff1bc..0000000
--- a/a/LICENSE-MIT
+++ /dev/null
@@ -1,23 +0,0 @@
-Copyright (c) 2012 Vladimir Keleshev, <vladimir@keleshev.com>
-
-Permission is hereby granted, free of charge, to any person
-obtaining a copy of this software and associated
-documentation files (the "Software"), to deal in the Software
-without restriction, including without limitation the rights
-to use, copy, modify, merge, publish, distribute, sublicense,
-and/or sell copies of the Software, and to permit persons to
-whom the Software is furnished to do so, subject to the
-following conditions:
-
-The above copyright notice and this permission notice shall
-be included in all copies or substantial portions of the
-Software.
-
-THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY
-KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
-WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR
-PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
-COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
-LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
-OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
-SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
diff --git a/a/README.rst b/a/README.rst
deleted file mode 100644
index 5fe8b4f..0000000
--- a/a/README.rst
+++ /dev/null
@@ -1,479 +0,0 @@
-``docopt.cpp``: A C++11 Port
-============================
-
-Contents
---------
-
-.. contents::
-  :local:
-  :depth: 3
-
-docopt creates *beautiful* command-line interfaces
---------------------------------------------------
-
-Isn't it awesome how ``getopt`` (and ``boost::program_options`` for you fancy
-folk!) generate help messages based on your code?! These timeless functions
-have been around for decades and have proven we don't need anything better, right?
-
-*Hell no!*  You know what's awesome?  It's when the option parser *is*
-generated based on the beautiful help message that you write yourself!
-This way you don't need to write this stupid repeatable parser-code,
-and instead can write only the help message--*the way you want it*.
-
-**docopt** helps you create most beautiful command-line interfaces
-*easily*:
-
-.. code:: c++
-
-    #include "docopt.h"
-
-    #include <iostream>
-
-    static const char USAGE[] =
-    R"(Naval Fate.
-
-        Usage:
-          naval_fate ship new <name>...
-          naval_fate ship <name> move <x> <y> [--speed=<kn>]
-          naval_fate ship shoot <x> <y>
-          naval_fate mine (set|remove) <x> <y> [--moored | --drifting]
-          naval_fate (-h | --help)
-          naval_fate --version
-
-        Options:
-          -h --help     Show this screen.
-          --version     Show version.
-          --speed=<kn>  Speed in knots [default: 10].
-          --moored      Moored (anchored) mine.
-          --drifting    Drifting mine.
-    )";
-
-    int main(int argc, const char** argv)
-    {
-        std::map<std::string, docopt::value> args
-            = docopt::docopt(USAGE,
-                             { argv + 1, argv + argc },
-                             true,               // show help if requested
-                             "Naval Fate 2.0");  // version string
-
-        for(auto const& arg : args) {
-            std::cout << arg.first <<  arg.second << std::endl;
-        }
-
-        return 0;
-    }
-
-Beat that! The option parser is generated based on the docstring above
-that is passed to ``docopt::docopt`` function.  ``docopt`` parses the usage
-pattern (``"Usage: ..."``) and option descriptions (lines starting
-with a dash "``-``") and ensures that the program invocation matches the
-usage pattern; it parses options, arguments and commands based on
-that. The basic idea is that *a good help message has all necessary
-information in it to make a parser*.
-
-Getting and using
------------------
-
-To get *docopt.cpp*, the simplest is to use `Conda <https://github.com/conda-forge/docopt.cpp-feedstock>`_::
-
-    conda install -c conda-forge docopt.cpp
-
-Alternatively manual installation is done using (unix)::
-
-    git clone
-    cmake .
-    make install
-
-To link *docopt.cpp*, the simplest is to use CMake. The general structure of your
-``CMakeLists.txt`` would be as follows::
-
-    cmake_minimum_required(VERSION 3.1)
-
-    project(example)
-
-    find_package(docopt COMPONENTS CXX REQUIRED)
-    include_directories(${DOCOPT_INCLUDE_DIRS})
-
-    add_executable(${PROJECT_NAME} ...)
-
-    target_link_libraries(${PROJECT_NAME} docopt)
-
-C++11 port details
-------------------
-
-This is a port of the ``docopt.py`` module (https://github.com/docopt/docopt),
-and we have tried to maintain full feature parity (and code structure) as the
-original.
-
-This port is written in C++11 and also requires a good C++11 standard library
-(in particular, one with ``regex`` support). The following compilers are known
-to work with docopt:
-
-- Clang 3.3 and later
-- GCC 4.9
-- Visual C++ 2015 RC
-
-GCC-4.8 can work, but the std::regex module needs to be replaced with ``Boost.Regex``.
-In that case, you will need to define ``DOCTOPT_USE_BOOST_REGEX`` when compiling
-docopt, and link your code with the appropriated Boost libraries. A relatively
-recent version of Boost is needed: 1.55 works, but 1.46 does not for example.
-
-This port is licensed under the MIT license, just like the original module.
-However, we are also dual-licensing this code under the Boost License, version 1.0,
-as this is a popular C++ license. The licenses are similar and you are free to
-use this code under the terms of either license.
-
-The differences from the Python port are:
-
-* the addition of a ``docopt_parse`` function, which does not terminate
-  the program on error
-* a ``docopt::value`` type to hold the various value types that can be parsed.
-  We considered using boost::variant, but it seems better to have no external
-  dependencies (beyond a good STL).
-* because C++ is statically-typed and Python is not, we had to make some
-  changes to the interfaces of the internal parse tree types.
-* because ``std::regex`` does not have an equivalent to Python's regex.split,
-  some of the regex's had to be restructured and additional loops used.
-
-API
----
-
-.. code:: c++
-
-    docopt::docopt(doc, argv, help /* =true */, version /* ="" */, options_first /* =false */)
-
-``docopt`` takes 2 required and 3 optional arguments:
-
-- ``doc`` is a string that contains a **help message** that will be parsed to
-  create the option parser.  The simple rules of how to write such a
-  help message are given in next sections.  Here is a quick example of
-  such a string (note that this example uses the "raw string literal" feature
-  that was added to C++11):
-
-.. code:: c++
-
-    R"(Usage: my_program [-hso FILE] [--quiet | --verbose] [INPUT ...]
-
-    -h --help    show this
-    -s --sorted  sorted output
-    -o FILE      specify output file [default: ./test.txt]
-    --quiet      print less text
-    --verbose    print more text
-    )"
-
-- ``argv`` is a vector of strings representing the args passed. Although
-  main usually takes a ``(int argc, const char** argv)`` pair, you can
-  pass the value ``{argv+1, argv+argc}`` to generate the vector automatically.
-  (Note we skip the argv[0] argument!) Alternatively you can supply a list of
-  strings like ``{ "--verbose", "-o", "hai.txt" }``.
-
-- ``help``, by default ``true``, specifies whether the parser should
-  automatically print the help message (supplied as ``doc``) and
-  terminate, in case ``-h`` or ``--help`` option is encountered
-  (options should exist in usage pattern, more on that below). If you
-  want to handle ``-h`` or ``--help`` options manually (as other
-  options), set ``help=false``.
-
-- ``version``, by default empty, is an optional argument that
-  specifies the version of your program. If supplied, then, (assuming
-  ``--version`` option is mentioned in usage pattern) when parser
-  encounters the ``--version`` option, it will print the supplied
-  version and terminate.  ``version`` could be any printable object,
-  but most likely a string, e.g. ``"2.1.0rc1"``.
-
-    Note, when ``docopt`` is set to automatically handle ``-h``,
-    ``--help`` and ``--version`` options, you still need to mention
-    them in usage pattern for this to work (also so your users to
-    know about them!)
-
-- ``options_first``, by default ``false``.  If set to ``true`` will
-  disallow mixing options and positional argument.  I.e. after first
-  positional argument, all arguments will be interpreted as positional
-  even if the look like options.  This can be used for strict
-  compatibility with POSIX, or if you want to dispatch your arguments
-  to other programs.
-
-The **return** value is a ``map<string, docopt::value>`` with options,
-arguments and commands as keys, spelled exactly like in your help message.
-Long versions of options are given priority. For example, if you invoke the
-top example as::
-
-    naval_fate ship Guardian move 100 150 --speed=15
-
-the return dictionary will be:
-
-.. code:: python
-
-    {"--drifting": false,    "mine": false,
-     "--help": false,        "move": true,
-     "--moored": false,      "new": false,
-     "--speed": "15",        "remove": false,
-     "--version": false,     "set": false,
-     "<name>": ["Guardian"], "ship": true,
-     "<x>": "100",           "shoot": false,
-     "<y>": "150"}
-
-If any parsing error (in either the usage, or due to incorrect user inputs) is
-encountered, the program will exit with exit code -1.
-
-Note that there is another function that does not exit on error, and instead will
-propagate an exception that you can catch and process as you like. See the docopt.h file
-for information on the exceptions and usage:
-
-.. code:: c++
-
-    docopt::docopt_parse(doc, argv, help /* =true */, version /* =true */, options_first /* =false)
-
-Help message format
--------------------
-
-Help message consists of 2 parts:
-
-- Usage pattern, e.g.::
-
-    Usage: my_program [-hso FILE] [--quiet | --verbose] [INPUT ...]
-
-- Option descriptions, e.g.::
-
-    -h --help    show this
-    -s --sorted  sorted output
-    -o FILE      specify output file [default: ./test.txt]
-    --quiet      print less text
-    --verbose    print more text
-
-Their format is described below; other text is ignored.
-
-Usage pattern format
---------------------
-
-**Usage pattern** is a substring of ``doc`` that starts with
-``usage:`` (case *insensitive*) and ends with a *visibly* empty line.
-Minimum example:
-
-.. code:: python
-
-    """Usage: my_program
-
-    """
-
-The first word after ``usage:`` is interpreted as your program's name.
-You can specify your program's name several times to signify several
-exclusive patterns:
-
-.. code:: python
-
-    """Usage: my_program FILE
-              my_program COUNT FILE
-
-    """
-
-Each pattern can consist of the following elements:
-
-- **<arguments>**, **ARGUMENTS**. Arguments are specified as either
-  upper-case words, e.g. ``my_program CONTENT-PATH`` or words
-  surrounded by angular brackets: ``my_program <content-path>``.
-- **--options**.  Options are words started with dash (``-``), e.g.
-  ``--output``, ``-o``.  You can "stack" several of one-letter
-  options, e.g. ``-oiv`` which will be the same as ``-o -i -v``. The
-  options can have arguments, e.g.  ``--input=FILE`` or ``-i FILE`` or
-  even ``-iFILE``. However it is important that you specify option
-  descriptions if you want your option to have an argument, a default
-  value, or specify synonymous short/long versions of the option (see
-  next section on option descriptions).
-- **commands** are words that do *not* follow the described above
-  conventions of ``--options`` or ``<arguments>`` or ``ARGUMENTS``,
-  plus two special commands: dash "``-``" and double dash "``--``"
-  (see below).
-
-Use the following constructs to specify patterns:
-
-- **[ ]** (brackets) **optional** elements.  e.g.: ``my_program
-  [-hvqo FILE]``
-- **( )** (parens) **required** elements.  All elements that are *not*
-  put in **[ ]** are also required, e.g.: ``my_program
-  --path=<path> <file>...`` is the same as ``my_program
-  (--path=<path> <file>...)``.  (Note, "required options" might be not
-  a good idea for your users).
-- **|** (pipe) **mutually exclusive** elements. Group them using **(
-  )** if one of the mutually exclusive elements is required:
-  ``my_program (--clockwise | --counter-clockwise) TIME``. Group
-  them using **[ ]** if none of the mutually exclusive elements are
-  required: ``my_program [--left | --right]``.
-- **...** (ellipsis) **one or more** elements. To specify that
-  arbitrary number of repeating elements could be accepted, use
-  ellipsis (``...``), e.g.  ``my_program FILE ...`` means one or
-  more ``FILE``-s are accepted.  If you want to accept zero or more
-  elements, use brackets, e.g.: ``my_program [FILE ...]``. Ellipsis
-  works as a unary operator on the expression to the left.
-- **[options]** (case sensitive) shortcut for any options.  You can
-  use it if you want to specify that the usage pattern could be
-  provided with any options defined below in the option-descriptions
-  and do not want to enumerate them all in usage-pattern.
-- "``[--]``". Double dash "``--``" is used by convention to separate
-  positional arguments that can be mistaken for options. In order to
-  support this convention add "``[--]``" to your usage patterns.
-- "``[-]``". Single dash "``-``" is used by convention to signify that
-  ``stdin`` is used instead of a file. To support this add "``[-]``"
-  to your usage patterns. "``-``" acts as a normal command.
-
-If your pattern allows to match argument-less option (a flag) several
-times::
-
-    Usage: my_program [-v | -vv | -vvv]
-
-then number of occurrences of the option will be counted. I.e.
-``args['-v']`` will be ``2`` if program was invoked as ``my_program
--vv``. Same works for commands.
-
-If your usage pattern allows to match same-named option with argument
-or positional argument several times, the matched arguments will be
-collected into a list::
-
-    Usage: my_program <file> <file> --path=<path>...
-
-I.e. invoked with ``my_program file1 file2 --path=./here
---path=./there`` the returned dict will contain ``args['<file>'] ==
-['file1', 'file2']`` and ``args['--path'] == ['./here', './there']``.
-
-Option descriptions format
---------------------------
-
-**Option descriptions** consist of a list of options that you put
-below your usage patterns.
-
-It is necessary to list option descriptions in order to specify:
-
-- synonymous short and long options,
-- if an option has an argument,
-- if option's argument has a default value.
-
-The rules are as follows:
-
-- Every line in ``doc`` that starts with ``-`` or ``--`` (not counting
-  spaces) is treated as an option description, e.g.::
-
-    Options:
-      --verbose   # GOOD
-      -o FILE     # GOOD
-    Other: --bad  # BAD, line does not start with dash "-"
-
-- To specify that option has an argument, put a word describing that
-  argument after space (or equals "``=``" sign) as shown below. Follow
-  either <angular-brackets> or UPPER-CASE convention for options'
-  arguments.  You can use comma if you want to separate options. In
-  the example below, both lines are valid. However you are recommended
-  to stick to a single style.::
-
-    -o FILE --output=FILE       # without comma, with "=" sign
-    -i <file>, --input <file>   # with comma, without "=" sing
-
-- Use two spaces to separate options with their informal description::
-
-    --verbose More text.   # BAD, will be treated as if verbose option had
-                           # an argument "More", so use 2 spaces instead
-    -q        Quit.        # GOOD
-    -o FILE   Output file. # GOOD
-    --stdout  Use stdout.  # GOOD, 2 spaces
-
-- If you want to set a default value for an option with an argument,
-  put it into the option-description, in form ``[default:
-  <my-default-value>]``::
-
-    --coefficient=K  The K coefficient [default: 2.95]
-    --output=FILE    Output file [default: test.txt]
-    --directory=DIR  Some directory [default: ./]
-
-- If the option is not repeatable, the value inside ``[default: ...]``
-  will be interpreted as string.  If it *is* repeatable, it will be
-  split into a list on whitespace::
-
-    Usage: my_program [--repeatable=<arg> --repeatable=<arg>]
-                         [--another-repeatable=<arg>]...
-                         [--not-repeatable=<arg>]
-
-    # will be ['./here', './there']
-    --repeatable=<arg>          [default: ./here ./there]
-
-    # will be ['./here']
-    --another-repeatable=<arg>  [default: ./here]
-
-    # will be './here ./there', because it is not repeatable
-    --not-repeatable=<arg>      [default: ./here ./there]
-
-Examples
---------
-
-We have an extensive list of `examples
-<https://github.com/docopt/docopt/tree/master/examples>`_ which cover
-every aspect of functionality of **docopt**.  Try them out, read the
-source if in doubt.
-
-There are also very interesting applications and ideas at that page.
-Check out the sister project for more information!
-
-Subparsers, multi-level help and *huge* applications (like git)
----------------------------------------------------------------
-
-If you want to split your usage-pattern into several, implement
-multi-level help (with separate help-screen for each subcommand),
-want to interface with existing scripts that don't use **docopt**, or
-you're building the next "git", you will need the new ``options_first``
-parameter (described in API section above). To get you started quickly
-we implemented a subset of git command-line interface as an example:
-`examples/git
-<https://github.com/docopt/docopt/tree/master/examples/git>`_
-
-Compiling the example / Running the tests
------------------------------------------
-
-The original Python module includes some language-agnostic unit tests,
-and these can be run with this port as well.
-
-The tests are a Python driver that uses the testcases.docopt file to then invoke
-a C++ test case runner (run_testcase.cpp)::
-
-  $ clang++ --std=c++11 --stdlib=libc++ docopt.cpp run_testcase.cpp -o run_testcase
-  $ python run_tests.py
-  PASS (175)
-
-You can also compile the example shown at the start (included as example.cpp)::
-
-  $ clang++ --std=c++11 --stdlib=libc++ -I . docopt.cpp examples/naval_fate.cpp -o naval_fate
-  $ ./naval_fate --help
-   [ ... ]
-  $ ./naval_fate ship Guardian move 100 150 --speed=15
-  --drifting: false
-  --help: false
-  --moored: false
-  --speed: "15"
-  --version: false
-  <name>: ["Guardian"]
-  <x>: "100"
-  <y>: "150"
-  mine: false
-  move: true
-  new: false
-  remove: false
-  set: false
-  ship: true
-  shoot: false
-
-Development
------------
-
-Comments and suggestions are *very* welcome! If you find issues, please
-file them and help improve our code!
-
-Please note, however, that we have tried to stay true to the original
-Python code. If you have any major patches, structural changes, or new features,
-we might want to first negotiate these changes into the Python code first.
-However, bring it up! Let's hear it!
-
-Changelog
----------
-
-**docopt** follows `semantic versioning <http://semver.org>`_.  The
-first release with stable API will be 1.0.0 (soon).
-
-- 0.6.2 Bugfix release (still based on docopt 0.6.1)
-- 0.6.1 The initial C++ port of docopt.py (based on docopt 0.6.1)
diff --git a/a/docopt-config.cmake b/a/docopt-config.cmake
deleted file mode 100644
index 33c36c0..0000000
--- a/a/docopt-config.cmake
+++ /dev/null
@@ -1 +0,0 @@
-include("${CMAKE_CURRENT_LIST_DIR}/docopt-targets.cmake")
diff --git a/a/docopt.cpp b/a/docopt.cpp
deleted file mode 100644
index c6ee9b9..0000000
--- a/a/docopt.cpp
+++ /dev/null
@@ -1,687 +0,0 @@
-//
-//  docopt.cpp
-//  docopt
-//
-//  Created by Jared Grubb on 2013-11-03.
-//  Copyright (c) 2013 Jared Grubb. All rights reserved.
-//
-
-#include "docopt.h"
-#include "docopt_util.h"
-#include "docopt_private.h"
-
-#include "docopt_value.h"
-
-#include <vector>
-#include <unordered_set>
-#include <unordered_map>
-#include <map>
-#include <string>
-#include <iostream>
-#include <cassert>
-#include <cstddef>
-
-using namespace docopt;
-
-DOCOPT_INLINE
-std::ostream& docopt::operator<<(std::ostream& os, value const& val)
-{
-	if (val.isBool()) {
-		bool b = val.asBool();
-		os << (b ? "true" : "false");
-	} else if (val.isLong()) {
-		long v = val.asLong();
-		os << v;
-	} else if (val.isString()) {
-		std::string const& str = val.asString();
-		os << '"' << str << '"';
-	} else if (val.isStringList()) {
-		auto const& list = val.asStringList();
-		os << "[";
-		bool first = true;
-		for(auto const& el : list) {
-			if (first) {
-				first = false;
-			} else {
-				os << ", ";
-			}
-			os << '"' << el << '"';
-		}
-		os << "]";
-	} else {
-		os << "null";
-	}
-	return os;
-}
-
-#if 0
-#pragma mark -
-#pragma mark Parsing stuff
-#endif
-
-class Tokens {
-public:
-	Tokens(std::vector<std::string> tokens, bool isParsingArgv = true)
-	: fTokens(std::move(tokens)),
-	  fIsParsingArgv(isParsingArgv)
-	{}
-
-	explicit operator bool() const {
-		return fIndex < fTokens.size();
-	}
-
-	static Tokens from_pattern(std::string const& source) {
-		static const std::regex re_separators {
-			"(?:\\s*)" // any spaces (non-matching subgroup)
-			"("
-			"[\\[\\]\\(\\)\\|]" // one character of brackets or parens or pipe character
-			"|"
-			"\\.\\.\\."  // elipsis
-			")" };
-
-		static const std::regex re_strings {
-			"(?:\\s*)" // any spaces (non-matching subgroup)
-			"("
-			"\\S*<.*?>"  // strings, but make sure to keep "< >" strings together
-			"|"
-			"[^<>\\s]+"     // string without <>
-			")" };
-
-		// We do two stages of regex matching. The '[]()' and '...' are strong delimeters
-		// and need to be split out anywhere they occur (even at the end of a token). We
-		// first split on those, and then parse the stuff between them to find the string
-		// tokens. This is a little harder than the python version, since they have regex.split
-		// and we dont have anything like that.
-
-		std::vector<std::string> tokens;
-		std::for_each(std::sregex_iterator{ source.begin(), source.end(), re_separators },
-			      std::sregex_iterator{},
-			      [&](std::smatch const& match)
-			      {
-				      // handle anything before the separator (this is the "stuff" between the delimeters)
-				      if (match.prefix().matched) {
-					      std::for_each(std::sregex_iterator{match.prefix().first, match.prefix().second, re_strings},
-							    std::sregex_iterator{},
-							    [&](std::smatch const& m)
-							    {
-								    tokens.push_back(m[1].str());
-							    });
-				      }
-
-				      // handle the delimter token itself
-				      if (match[1].matched) {
-					      tokens.push_back(match[1].str());
-				      }
-			      });
-
-		return Tokens(tokens, false);
-	}
-
-	std::string const& current() const {
-		if (*this)
-			return fTokens[fIndex];
-
-		static std::string const empty;
-		return empty;
-	}
-
-	std::string the_rest() const {
-		if (!*this)
-			return {};
-		return join(fTokens.begin()+static_cast<std::ptrdiff_t>(fIndex),
-			    fTokens.end(),
-			    " ");
-	}
-
-	std::string pop() {
-		return std::move(fTokens.at(fIndex++));
-	}
-
-	bool isParsingArgv() const { return fIsParsingArgv; }
-
-	struct OptionError : std::runtime_error { using runtime_error::runtime_error; };
-
-private:
-	std::vector<std::string> fTokens;
-	size_t fIndex = 0;
-	bool fIsParsingArgv;
-};
-
-// Get all instances of 'T' from the pattern
-template <typename T>
-std::vector<T*> flat_filter(Pattern& pattern) {
-	std::vector<Pattern*> flattened = pattern.flat([](Pattern const* p) -> bool {
-		return dynamic_cast<T const*>(p) != nullptr;
-	});
-
-	// now, we're guaranteed to have T*'s, so just use static_cast
-	std::vector<T*> ret;
-	std::transform(flattened.begin(), flattened.end(), std::back_inserter(ret), [](Pattern* p) {
-		return static_cast<T*>(p);
-	});
-	return ret;
-}
-
-static std::vector<std::string> parse_section(std::string const& name, std::string const& source) {
-	// ECMAScript regex only has "?=" for a non-matching lookahead. In order to make sure we always have
-	// a newline to anchor our matching, we have to avoid matching the final newline of each grouping.
-	// Therefore, our regex is adjusted from the docopt Python one to use ?= to match the newlines before
-	// the following lines, rather than after.
-	std::regex const re_section_pattern {
-		"(?:^|\\n)"  // anchored at a linebreak (or start of string)
-		"("
-		   "[^\\n]*" + name + "[^\\n]*(?=\\n?)" // a line that contains the name
-		   "(?:\\n[ \\t].*?(?=\\n|$))*"         // followed by any number of lines that are indented
-		")",
-		std::regex::icase
-	};
-
-	std::vector<std::string> ret;
-	std::for_each(std::sregex_iterator(source.begin(), source.end(), re_section_pattern),
-		      std::sregex_iterator(),
-		      [&](std::smatch const& match)
-	{
-		ret.push_back(trim(match[1].str()));
-	});
-
-	return ret;
-}
-
-static bool is_argument_spec(std::string const& token) {
-	if (token.empty())
-		return false;
-
-	if (token[0]=='<' && token[token.size()-1]=='>')
-		return true;
-
-	if (std::all_of(token.begin(), token.end(), &::isupper))
-		return true;
-
-	return false;
-}
-
-template <typename I>
-std::vector<std::string> longOptions(I iter, I end) {
-	std::vector<std::string> ret;
-	std::transform(iter, end,
-		       std::back_inserter(ret),
-		       [](typename I::reference opt) { return opt->longOption(); });
-	return ret;
-}
-
-static PatternList parse_long(Tokens& tokens, std::vector<Option>& options)
-{
-	// long ::= '--' chars [ ( ' ' | '=' ) chars ] ;
-	std::string longOpt, equal;
-	value val;
-	std::tie(longOpt, equal, val) = partition(tokens.pop(), "=");
-
-	assert(starts_with(longOpt, "--"));
-
-	if (equal.empty()) {
-		val = value{};
-	}
-
-	// detect with options match this long option
-	std::vector<Option const*> similar;
-	for(auto const& option : options) {
-		if (option.longOption()==longOpt)
-			similar.push_back(&option);
-	}
-
-	// maybe allow similar options that match by prefix
-	if (tokens.isParsingArgv() && similar.empty()) {
-		for(auto const& option : options) {
-			if (option.longOption().empty())
-				continue;
-			if (starts_with(option.longOption(), longOpt))
-				similar.push_back(&option);
-		}
-	}
-
-	PatternList ret;
-
-	if (similar.size() > 1) { // might be simply specified ambiguously 2+ times?
-		std::vector<std::string> prefixes = longOptions(similar.begin(), similar.end());
-		std::string error = "'" + longOpt + "' is not a unique prefix: ";
-		error.append(join(prefixes.begin(), prefixes.end(), ", "));
-		throw Tokens::OptionError(std::move(error));
-	} else if (similar.empty()) {
-		int argcount = equal.empty() ? 0 : 1;
-		options.emplace_back("", longOpt, argcount);
-
-		auto o = std::make_shared<Option>(options.back());
-		if (tokens.isParsingArgv()) {
-			o->setValue(argcount ? value{val} : value{true});
-		}
-		ret.push_back(o);
-	} else {
-		auto o = std::make_shared<Option>(*similar[0]);
-		if (o->argCount() == 0) {
-			if (val) {
-				std::string error = o->longOption() + " must not have an argument";
-				throw Tokens::OptionError(std::move(error));
-			}
-		} else {
-			if (!val) {
-				auto const& token = tokens.current();
-				if (token.empty() || token=="--") {
-					std::string error = o->longOption() + " requires an argument";
-					throw Tokens::OptionError(std::move(error));
-				}
-				val = tokens.pop();
-			}
-		}
-		if (tokens.isParsingArgv()) {
-			o->setValue(val ? std::move(val) : value{true});
-		}
-		ret.push_back(o);
-	}
-
-	return ret;
-}
-
-static PatternList parse_short(Tokens& tokens, std::vector<Option>& options)
-{
-	// shorts ::= '-' ( chars )* [ [ ' ' ] chars ] ;
-
-	auto token = tokens.pop();
-
-	assert(starts_with(token, "-"));
-	assert(!starts_with(token, "--"));
-
-	auto i = token.begin();
-	++i; // skip the leading '-'
-
-	PatternList ret;
-	while (i != token.end()) {
-		std::string shortOpt = { '-', *i };
-		++i;
-
-		std::vector<Option const*> similar;
-		for(auto const& option : options) {
-			if (option.shortOption()==shortOpt)
-				similar.push_back(&option);
-		}
-
-		if (similar.size() > 1) {
-			std::string error = shortOpt + " is specified ambiguously "
-			+ std::to_string(similar.size()) + " times";
-			throw Tokens::OptionError(std::move(error));
-		} else if (similar.empty()) {
-			options.emplace_back(shortOpt, "", 0);
-
-			auto o = std::make_shared<Option>(options.back());
-			if (tokens.isParsingArgv()) {
-				o->setValue(value{true});
-			}
-			ret.push_back(o);
-		} else {
-			auto o = std::make_shared<Option>(*similar[0]);
-			value val;
-			if (o->argCount()) {
-				if (i == token.end()) {
-					// consume the next token
-					auto const& ttoken = tokens.current();
-					if (ttoken.empty() || ttoken=="--") {
-						std::string error = shortOpt + " requires an argument";
-						throw Tokens::OptionError(std::move(error));
-					}
-					val = tokens.pop();
-				} else {
-					// consume all the rest
-					val = std::string{i, token.end()};
-					i = token.end();
-				}
-			}
-
-			if (tokens.isParsingArgv()) {
-				o->setValue(val ? std::move(val) : value{true});
-			}
-			ret.push_back(o);
-		}
-	}
-
-	return ret;
-}
-
-static PatternList parse_expr(Tokens& tokens, std::vector<Option>& options);
-
-static PatternList parse_atom(Tokens& tokens, std::vector<Option>& options)
-{
-	// atom ::= '(' expr ')' | '[' expr ']' | 'options'
-	//             | long | shorts | argument | command ;
-
-	std::string const& token = tokens.current();
-
-	PatternList ret;
-
-	if (token == "[") {
-		tokens.pop();
-
-		auto expr = parse_expr(tokens, options);
-
-		auto trailing = tokens.pop();
-		if (trailing != "]") {
-			throw DocoptLanguageError("Mismatched '['");
-		}
-
-		ret.emplace_back(std::make_shared<Optional>(std::move(expr)));
-	} else if (token=="(") {
-		tokens.pop();
-
-		auto expr = parse_expr(tokens, options);
-
-		auto trailing = tokens.pop();
-		if (trailing != ")") {
-			throw DocoptLanguageError("Mismatched '('");
-		}
-
-		ret.emplace_back(std::make_shared<Required>(std::move(expr)));
-	} else if (token == "options") {
-		tokens.pop();
-		ret.emplace_back(std::make_shared<OptionsShortcut>());
-	} else if (starts_with(token, "--") && token != "--") {
-		ret = parse_long(tokens, options);
-	} else if (starts_with(token, "-") && token != "-" && token != "--") {
-		ret = parse_short(tokens, options);
-	} else if (is_argument_spec(token)) {
-		ret.emplace_back(std::make_shared<Argument>(tokens.pop()));
-	} else {
-		ret.emplace_back(std::make_shared<Command>(tokens.pop()));
-	}
-
-	return ret;
-}
-
-static PatternList parse_seq(Tokens& tokens, std::vector<Option>& options)
-{
-	// seq ::= ( atom [ '...' ] )* ;"""
-
-	PatternList ret;
-
-	while (tokens) {
-		auto const& token = tokens.current();
-
-		if (token=="]" || token==")" || token=="|")
-			break;
-
-		auto atom = parse_atom(tokens, options);
-		if (tokens.current() == "...") {
-			ret.emplace_back(std::make_shared<OneOrMore>(std::move(atom)));
-			tokens.pop();
-		} else {
-			std::move(atom.begin(), atom.end(), std::back_inserter(ret));
-		}
-	}
-
-	return ret;
-}
-
-static std::shared_ptr<Pattern> maybe_collapse_to_required(PatternList&& seq)
-{
-	if (seq.size()==1) {
-		return std::move(seq[0]);
-	}
-	return std::make_shared<Required>(std::move(seq));
-}
-
-static std::shared_ptr<Pattern> maybe_collapse_to_either(PatternList&& seq)
-{
-	if (seq.size()==1) {
-		return std::move(seq[0]);
-	}
-	return std::make_shared<Either>(std::move(seq));
-}
-
-PatternList parse_expr(Tokens& tokens, std::vector<Option>& options)
-{
-	// expr ::= seq ( '|' seq )* ;
-
-	auto seq = parse_seq(tokens, options);
-
-	if (tokens.current() != "|")
-		return seq;
-
-	PatternList ret;
-	ret.emplace_back(maybe_collapse_to_required(std::move(seq)));
-
-	while (tokens.current() == "|") {
-		tokens.pop();
-		seq = parse_seq(tokens, options);
-		ret.emplace_back(maybe_collapse_to_required(std::move(seq)));
-	}
-
-	return { maybe_collapse_to_either(std::move(ret)) };
-}
-
-static Required parse_pattern(std::string const& source, std::vector<Option>& options)
-{
-	auto tokens = Tokens::from_pattern(source);
-	auto result = parse_expr(tokens, options);
-
-	if (tokens)
-		throw DocoptLanguageError("Unexpected ending: '" + tokens.the_rest() + "'");
-
-	assert(result.size() == 1  &&  "top level is always one big");
-	return Required{ std::move(result) };
-}
-
-
-static std::string formal_usage(std::string const& section) {
-	std::string ret = "(";
-
-	auto i = section.find(':')+1;  // skip past "usage:"
-	auto parts = split(section, i);
-	for(size_t ii = 1; ii < parts.size(); ++ii) {
-		if (parts[ii] == parts[0]) {
-			ret += " ) | (";
-		} else {
-			ret.push_back(' ');
-			ret += parts[ii];
-		}
-	}
-
-	ret += " )";
-	return ret;
-}
-
-static PatternList parse_argv(Tokens tokens, std::vector<Option>& options, bool options_first)
-{
-	// Parse command-line argument vector.
-	//
-	// If options_first:
-	//    argv ::= [ long | shorts ]* [ argument ]* [ '--' [ argument ]* ] ;
-	// else:
-	//    argv ::= [ long | shorts | argument ]* [ '--' [ argument ]* ] ;
-
-	PatternList ret;
-	while (tokens) {
-		auto const& token = tokens.current();
-
-		if (token=="--") {
-			// option list is done; convert all the rest to arguments
-			while (tokens) {
-				ret.emplace_back(std::make_shared<Argument>("", tokens.pop()));
-			}
-		} else if (starts_with(token, "--")) {
-			auto&& parsed = parse_long(tokens, options);
-			std::move(parsed.begin(), parsed.end(), std::back_inserter(ret));
-		} else if (token[0]=='-' && token != "-") {
-			auto&& parsed = parse_short(tokens, options);
-			std::move(parsed.begin(), parsed.end(), std::back_inserter(ret));
-		} else if (options_first) {
-			// option list is done; convert all the rest to arguments
-			while (tokens) {
-				ret.emplace_back(std::make_shared<Argument>("", tokens.pop()));
-			}
-		} else {
-			ret.emplace_back(std::make_shared<Argument>("", tokens.pop()));
-		}
-	}
-
-	return ret;
-}
-
-static std::vector<Option> parse_defaults(std::string const& doc) {
-	// This pattern is a delimiter by which we split the options.
-	// The delimiter is a new line followed by a whitespace(s) followed by one or two hyphens.
-	static std::regex const re_delimiter{
-		"(?:^|\\n)[ \\t]*"  // a new line with leading whitespace
-		"(?=-{1,2})"        // [split happens here] (positive lookahead) ... and followed by one or two hyphes
-	};
-
-	std::vector<Option> defaults;
-	for (auto s : parse_section("options:", doc)) {
-		s.erase(s.begin(), s.begin() + static_cast<std::ptrdiff_t>(s.find(':')) + 1); // get rid of "options:"
-
-		for (const auto& opt : regex_split(s, re_delimiter)) {
-			if (starts_with(opt, "-")) {
-				defaults.emplace_back(Option::parse(opt));
-			}
-		}
-	}
-
-	return defaults;
-}
-
-static bool isOptionSet(PatternList const& options, std::string const& opt1, std::string const& opt2 = "") {
-	return std::any_of(options.begin(), options.end(), [&](std::shared_ptr<Pattern const> const& opt) -> bool {
-		auto const& name = opt->name();
-		if (name==opt1 || (!opt2.empty() && name==opt2)) {
-			return opt->hasValue();
-		}
-		return false;
-	});
-}
-
-static void extras(bool help, bool version, PatternList const& options) {
-	if (help && isOptionSet(options, "-h", "--help")) {
-		throw DocoptExitHelp();
-	}
-
-	if (version && isOptionSet(options, "--version")) {
-		throw DocoptExitVersion();
-	}
-}
-
-// Parse the doc string and generate the Pattern tree
-static std::pair<Required, std::vector<Option>> create_pattern_tree(std::string const& doc)
-{
-	auto usage_sections = parse_section("usage:", doc);
-	if (usage_sections.empty()) {
-		throw DocoptLanguageError("'usage:' (case-insensitive) not found.");
-	}
-	if (usage_sections.size() > 1) {
-		throw DocoptLanguageError("More than one 'usage:' (case-insensitive).");
-	}
-
-	std::vector<Option> options = parse_defaults(doc);
-	Required pattern = parse_pattern(formal_usage(usage_sections[0]), options);
-
-	std::vector<Option const*> pattern_options = flat_filter<Option const>(pattern);
-
-	using UniqueOptions = std::unordered_set<Option const*, PatternHasher, PatternPointerEquality>;
-	UniqueOptions const uniq_pattern_options { pattern_options.begin(), pattern_options.end() };
-
-	// Fix up any "[options]" shortcuts with the actual option tree
-	for(auto& options_shortcut : flat_filter<OptionsShortcut>(pattern)) {
-		std::vector<Option> doc_options = parse_defaults(doc);
-
-		// set(doc_options) - set(pattern_options)
-		UniqueOptions uniq_doc_options;
-		for(auto const& opt : doc_options) {
-			if (uniq_pattern_options.count(&opt))
-				continue;
-			uniq_doc_options.insert(&opt);
-		}
-
-		// turn into shared_ptr's and set as children
-		PatternList children;
-		std::transform(uniq_doc_options.begin(), uniq_doc_options.end(),
-			       std::back_inserter(children), [](Option const* opt) {
-				       return std::make_shared<Option>(*opt);
-			       });
-		options_shortcut->setChildren(std::move(children));
-	}
-
-	return { std::move(pattern), std::move(options) };
-}
-
-DOCOPT_INLINE
-docopt::Options
-docopt::docopt_parse(std::string const& doc,
-		     std::vector<std::string> const& argv,
-		     bool help,
-		     bool version,
-		     bool options_first)
-{
-	Required pattern;
-	std::vector<Option> options;
-	try {
-		std::tie(pattern, options) = create_pattern_tree(doc);
-	} catch (Tokens::OptionError const& error) {
-		throw DocoptLanguageError(error.what());
-	}
-
-	PatternList argv_patterns;
-	try {
-		argv_patterns = parse_argv(Tokens(argv), options, options_first);
-	} catch (Tokens::OptionError const& error) {
-		throw DocoptArgumentError(error.what());
-	}
-
-	extras(help, version, argv_patterns);
-
-	std::vector<std::shared_ptr<LeafPattern>> collected;
-	bool matched = pattern.fix().match(argv_patterns, collected);
-	if (matched && argv_patterns.empty()) {
-		docopt::Options ret;
-
-		// (a.name, a.value) for a in (pattern.flat() + collected)
-		for (auto* p : pattern.leaves()) {
-			ret[p->name()] = p->getValue();
-		}
-
-		for (auto const& p : collected) {
-			ret[p->name()] = p->getValue();
-		}
-
-		return ret;
-	}
-
-	if (matched) {
-		std::string leftover = join(argv.begin(), argv.end(), ", ");
-		throw DocoptArgumentError("Unexpected argument: " + leftover);
-	}
-
-	throw DocoptArgumentError("Arguments did not match expected patterns"); // BLEH. Bad error.
-}
-
-DOCOPT_INLINE
-docopt::Options
-docopt::docopt(std::string const& doc,
-	       std::vector<std::string> const& argv,
-	       bool help,
-	       std::string const& version,
-	       bool options_first) noexcept
-{
-	try {
-		return docopt_parse(doc, argv, help, !version.empty(), options_first);
-	} catch (DocoptExitHelp const&) {
-		std::cout << doc << std::endl;
-		std::exit(0);
-	} catch (DocoptExitVersion const&) {
-		std::cout << version << std::endl;
-		std::exit(0);
-	} catch (DocoptLanguageError const& error) {
-		std::cerr << "Docopt usage string could not be parsed" << std::endl;
-		std::cerr << error.what() << std::endl;
-		std::exit(-1);
-	} catch (DocoptArgumentError const& error) {
-		std::cerr << error.what();
-		std::cout << std::endl;
-		std::cout << doc << std::endl;
-		std::exit(-1);
-	} /* Any other exception is unexpected: let std::terminate grab it */
-}
diff --git a/a/docopt.h b/a/docopt.h
deleted file mode 100644
index a59b5ed..0000000
--- a/a/docopt.h
+++ /dev/null
@@ -1,98 +0,0 @@
-//
-//  docopt.h
-//  docopt
-//
-//  Created by Jared Grubb on 2013-11-03.
-//  Copyright (c) 2013 Jared Grubb. All rights reserved.
-//
-
-#ifndef docopt__docopt_h_
-#define docopt__docopt_h_
-
-#ifdef DOCOPT_HEADER_ONLY
-    #define DOCOPT_INLINE inline
-    #define DOCOPT_API
-#else 
-    #define DOCOPT_INLINE
-
-    // With Microsoft Visual Studio, export certain symbols so they 
-    // are available to users of docopt.dll (shared library). The DOCOPT_DLL
-    // macro should be defined if building a DLL (with Visual Studio),
-    // and by clients using the DLL. The CMakeLists.txt and the
-    // docopt-config.cmake it generates handle this.
-    #ifdef DOCOPT_DLL
-        // Whoever is *building* the DLL should define DOCOPT_EXPORTS.
-        // The CMakeLists.txt that comes with docopt does this.
-        // Clients of docopt.dll should NOT define DOCOPT_EXPORTS.
-        #ifdef DOCOPT_EXPORTS
-            #define DOCOPT_API __declspec(dllexport)
-        #else
-            #define DOCOPT_API __declspec(dllimport)
-        #endif
-    #else
-        #define DOCOPT_API
-    #endif
-#endif
-
-#include "docopt_value.h"
-
-#include <map>
-#include <vector>
-#include <string>
-#include <stdexcept>
-
-namespace docopt {
-	
-	// Usage string could not be parsed (ie, the developer did something wrong)
-	struct DocoptLanguageError : std::runtime_error { using runtime_error::runtime_error; };
-	
-	// Arguments passed by user were incorrect (ie, developer was good, user is wrong)
-	struct DocoptArgumentError : std::runtime_error { using runtime_error::runtime_error; };
-	
-	// Arguments contained '--help' and parsing was aborted early
-	struct DocoptExitHelp : std::runtime_error { DocoptExitHelp() : std::runtime_error("Docopt --help argument encountered"){} };
-
-	// Arguments contained '--version' and parsing was aborted early
-	struct DocoptExitVersion : std::runtime_error { DocoptExitVersion() : std::runtime_error("Docopt --version argument encountered") {} };
-
-	/// A map of options set by the user
-	using Options = std::map<std::string, value>;
-	
-	/// Parse user options from the given option string.
-	///
-	/// @param doc   The usage string
-	/// @param argv  The user-supplied arguments
-	/// @param help  Whether to end early if '-h' or '--help' is in the argv
-	/// @param version Whether to end early if '--version' is in the argv
-	/// @param options_first  Whether options must precede all args (true), or if args and options
-	///                can be arbitrarily mixed.
-	///
-	/// @throws DocoptLanguageError if the doc usage string had errors itself
-	/// @throws DocoptExitHelp if 'help' is true and the user has passed the '--help' argument
-	/// @throws DocoptExitVersion if 'version' is true and the user has passed the '--version' argument
-	/// @throws DocoptArgumentError if the user's argv did not match the usage patterns
-	Options DOCOPT_API docopt_parse(std::string const& doc,
-					    std::vector<std::string> const& argv,
-					    bool help = true,
-					    bool version = true,
-					    bool options_first = false);
-	
-	/// Parse user options from the given string, and exit appropriately
-	///
-	/// Calls 'docopt_parse' and will terminate the program if any of the exceptions above occur:
-	///  * DocoptLanguageError - print error and terminate (with exit code -1)
-	///  * DocoptExitHelp - print usage string and terminate (with exit code 0)
-	///  * DocoptExitVersion - print version and terminate (with exit code 0)
-	///  * DocoptArgumentError - print error and usage string and terminate (with exit code -1)
-	Options DOCOPT_API docopt(std::string const& doc,
-					    std::vector<std::string> const& argv,
-					    bool help = true,
-					    std::string const& version = {},
-					    bool options_first = false) noexcept;
-}
-
-#ifdef DOCOPT_HEADER_ONLY
-    #include "docopt.cpp"
-#endif
-
-#endif /* defined(docopt__docopt_h_) */
diff --git a/a/docopt.pc.in b/a/docopt.pc.in
deleted file mode 100644
index 0ac4ffd..0000000
--- a/a/docopt.pc.in
+++ /dev/null
@@ -1,9 +0,0 @@
-libdir=@CMAKE_INSTALL_PREFIX@/@CMAKE_INSTALL_LIBDIR@
-includedir=@CMAKE_INSTALL_PREFIX@/include/docopt
-
-Name: docopt.cpp
-Description: C++11 port of docopt
-Version: @PROJECT_VERSION@
-Requires:
-Libs: -L${libdir} -ldocopt
-Cflags: -I${includedir}
diff --git a/a/docopt_private.h b/a/docopt_private.h
deleted file mode 100644
index 931986b..0000000
--- a/a/docopt_private.h
+++ /dev/null
@@ -1,676 +0,0 @@
-//
-//  docopt_private.h
-//  docopt
-//
-//  Created by Jared Grubb on 2013-11-04.
-//  Copyright (c) 2013 Jared Grubb. All rights reserved.
-//
-
-#ifndef docopt_docopt_private_h
-#define docopt_docopt_private_h
-
-#include <vector>
-#include <memory>
-#include <unordered_set>
-#include <assert.h>
-
-// Workaround GCC 4.8 not having std::regex
-#if DOCTOPT_USE_BOOST_REGEX
-#include <boost/regex.hpp>
-namespace std {
-	using boost::regex;
-   	using boost::sregex_iterator;
-   	using boost::smatch;
-   	using boost::regex_search;
-   	namespace regex_constants {
-		using boost::regex_constants::match_not_null;
-   	}
-}
-#else
-#include <regex>
-#endif
-
-#include "docopt_value.h"
-
-namespace docopt {
-
-	class Pattern;
-	class LeafPattern;
-
-	using PatternList = std::vector<std::shared_ptr<Pattern>>;
-
-	// Utility to use Pattern types in std hash-containers
-	struct PatternHasher {
-		template <typename P>
-		size_t operator()(std::shared_ptr<P> const& pattern) const {
-			return pattern->hash();
-		}
-		template <typename P>
-		size_t operator()(P const* pattern) const {
-			return pattern->hash();
-		}
-		template <typename P>
-		size_t operator()(P const& pattern) const {
-			return pattern.hash();
-		}
-	};
-
-	// Utility to use 'hash' as the equality operator as well in std containers
-	struct PatternPointerEquality {
-		template <typename P1, typename P2>
-		bool operator()(std::shared_ptr<P1> const& p1, std::shared_ptr<P2> const& p2) const {
-			return p1->hash()==p2->hash();
-		}
-		template <typename P1, typename P2>
-		bool operator()(P1 const* p1, P2 const* p2) const {
-			return p1->hash()==p2->hash();
-		}
-	};
-
-	// A hash-set that uniques by hash value
-	using UniquePatternSet = std::unordered_set<std::shared_ptr<Pattern>, PatternHasher, PatternPointerEquality>;
-
-
-	class Pattern {
-	public:
-		// flatten out children, stopping descent when the given filter returns 'true'
-		virtual std::vector<Pattern*> flat(bool (*filter)(Pattern const*)) = 0;
-
-		// flatten out all children into a list of LeafPattern objects
-		virtual void collect_leaves(std::vector<LeafPattern*>&) = 0;
-
-		// flatten out all children into a list of LeafPattern objects
-		std::vector<LeafPattern*> leaves();
-
-		// Attempt to find something in 'left' that matches this pattern's spec, and if so, move it to 'collected'
-		virtual bool match(PatternList& left, std::vector<std::shared_ptr<LeafPattern>>& collected) const = 0;
-
-		virtual std::string const& name() const = 0;
-
-		virtual bool hasValue() const { return false; }
-
-		virtual size_t hash() const = 0;
-
-		virtual ~Pattern() = default;
-	};
-
-	class LeafPattern
-	: public Pattern {
-	public:
-		LeafPattern(std::string name, value v = {})
-		: fName(std::move(name)),
-		  fValue(std::move(v))
-		{}
-
-		virtual std::vector<Pattern*> flat(bool (*filter)(Pattern const*)) override {
-			if (filter(this)) {
-				return { this };
-			}
-			return {};
-		}
-
-		virtual void collect_leaves(std::vector<LeafPattern*>& lst) override final {
-			lst.push_back(this);
-		}
-
-		virtual bool match(PatternList& left, std::vector<std::shared_ptr<LeafPattern>>& collected) const override;
-
-		virtual bool hasValue() const override { return static_cast<bool>(fValue); }
-
-		value const& getValue() const { return fValue; }
-		void setValue(value&& v) { fValue = std::move(v); }
-
-		virtual std::string const& name() const override { return fName; }
-
-		virtual size_t hash() const override {
-			size_t seed = typeid(*this).hash_code();
-			hash_combine(seed, fName);
-			hash_combine(seed, fValue);
-			return seed;
-		}
-
-	protected:
-		virtual std::pair<size_t, std::shared_ptr<LeafPattern>> single_match(PatternList const&) const = 0;
-
-	private:
-		std::string fName;
-		value fValue;
-	};
-
-	class BranchPattern
-	: public Pattern {
-	public:
-		BranchPattern(PatternList children = {})
-		: fChildren(std::move(children))
-		{}
-
-		Pattern& fix() {
-			UniquePatternSet patterns;
-			fix_identities(patterns);
-			fix_repeating_arguments();
-			return *this;
-		}
-
-		virtual std::string const& name() const override {
-			throw std::runtime_error("Logic error: name() shouldnt be called on a BranchPattern");
-		}
-
-		virtual value const& getValue() const {
-			throw std::runtime_error("Logic error: name() shouldnt be called on a BranchPattern");
-		}
-
-		virtual std::vector<Pattern*> flat(bool (*filter)(Pattern const*)) override {
-			if (filter(this)) {
-				return {this};
-			}
-
-			std::vector<Pattern*> ret;
-			for(auto& child : fChildren) {
-				auto sublist = child->flat(filter);
-				ret.insert(ret.end(), sublist.begin(), sublist.end());
-			}
-			return ret;
-		}
-
-		virtual void collect_leaves(std::vector<LeafPattern*>& lst) override final {
-			for(auto& child : fChildren) {
-				child->collect_leaves(lst);
-			}
-		}
-
-		void setChildren(PatternList children) {
-			fChildren = std::move(children);
-		}
-
-		PatternList const& children() const { return fChildren; }
-
-		virtual void fix_identities(UniquePatternSet& patterns) {
-			for(auto& child : fChildren) {
-				// this will fix up all its children, if needed
-				if (auto bp = dynamic_cast<BranchPattern*>(child.get())) {
-					bp->fix_identities(patterns);
-				}
-
-				// then we try to add it to the list
-				auto inserted = patterns.insert(child);
-				if (!inserted.second) {
-					// already there? then reuse the existing shared_ptr for that thing
-					child = *inserted.first;
-				}
-			}
-		}
-
-		virtual size_t hash() const override {
-			size_t seed = typeid(*this).hash_code();
-			hash_combine(seed, fChildren.size());
-			for(auto const& child : fChildren) {
-				hash_combine(seed, child->hash());
-			}
-			return seed;
-		}
-	private:
-		void fix_repeating_arguments();
-
-	protected:
-		PatternList fChildren;
-	};
-
-	class Argument
-	: public LeafPattern {
-	public:
-		using LeafPattern::LeafPattern;
-
-	protected:
-		virtual std::pair<size_t, std::shared_ptr<LeafPattern>> single_match(PatternList const& left) const override;
-	};
-
-	class Command : public Argument {
-	public:
-		Command(std::string name, value v = value{false})
-		: Argument(std::move(name), std::move(v))
-		{}
-
-	protected:
-		virtual std::pair<size_t, std::shared_ptr<LeafPattern>> single_match(PatternList const& left) const override;
-	};
-
-	class Option final
-	: public LeafPattern
-	{
-	public:
-		static Option parse(std::string const& option_description);
-
-		Option(std::string shortOption,
-		       std::string longOption,
-		       int argcount = 0,
-		       value v = value{false})
-		: LeafPattern(longOption.empty() ? shortOption : longOption,
-			      std::move(v)),
-		  fShortOption(std::move(shortOption)),
-		  fLongOption(std::move(longOption)),
-		  fArgcount(argcount)
-		{
-			// From Python:
-			//   self.value = None if value is False and argcount else value
-			if (argcount && v.isBool() && !v.asBool()) {
-				setValue(value{});
-			}
-		}
-
-		Option(Option const&) = default;
-		Option(Option&&) = default;
-		Option& operator=(Option const&) = default;
-		Option& operator=(Option&&) = default;
-
-		using LeafPattern::setValue;
-
-		std::string const& longOption() const { return fLongOption; }
-		std::string const& shortOption() const { return fShortOption; }
-		int argCount() const { return fArgcount; }
-
-		virtual size_t hash() const override {
-			size_t seed = LeafPattern::hash();
-			hash_combine(seed, fShortOption);
-			hash_combine(seed, fLongOption);
-			hash_combine(seed, fArgcount);
-			return seed;
-		}
-
-	protected:
-		virtual std::pair<size_t, std::shared_ptr<LeafPattern>> single_match(PatternList const& left) const override;
-
-	private:
-		std::string fShortOption;
-		std::string fLongOption;
-		int fArgcount;
-	};
-
-	class Required : public BranchPattern {
-	public:
-		using BranchPattern::BranchPattern;
-
-		bool match(PatternList& left, std::vector<std::shared_ptr<LeafPattern>>& collected) const override;
-	};
-
-	class Optional : public BranchPattern {
-	public:
-		using BranchPattern::BranchPattern;
-
-		bool match(PatternList& left, std::vector<std::shared_ptr<LeafPattern>>& collected) const override {
-			for(auto const& pattern : fChildren) {
-				pattern->match(left, collected);
-			}
-			return true;
-		}
-	};
-
-	class OptionsShortcut : public Optional {
-		using Optional::Optional;
-	};
-
-	class OneOrMore : public BranchPattern {
-	public:
-		using BranchPattern::BranchPattern;
-
-		bool match(PatternList& left, std::vector<std::shared_ptr<LeafPattern>>& collected) const override;
-	};
-
-	class Either : public BranchPattern {
-	public:
-		using BranchPattern::BranchPattern;
-
-		bool match(PatternList& left, std::vector<std::shared_ptr<LeafPattern>>& collected) const override;
-	};
-
-#if 0
-#pragma mark -
-#pragma mark inline implementations
-#endif
-
-	inline std::vector<LeafPattern*> Pattern::leaves()
-	{
-		std::vector<LeafPattern*> ret;
-		collect_leaves(ret);
-		return ret;
-	}
-
-	static inline std::vector<PatternList> transform(PatternList pattern)
-	{
-		std::vector<PatternList> result;
-
-		std::vector<PatternList> groups;
-		groups.emplace_back(std::move(pattern));
-
-		while(!groups.empty()) {
-			// pop off the first element
-			auto children = std::move(groups[0]);
-			groups.erase(groups.begin());
-
-			// find the first branch node in the list
-			auto child_iter = std::find_if(children.begin(), children.end(), [](std::shared_ptr<Pattern> const& p) {
-				return dynamic_cast<BranchPattern const*>(p.get());
-			});
-
-			// no branch nodes left : expansion is complete for this grouping
-			if (child_iter == children.end()) {
-				result.emplace_back(std::move(children));
-				continue;
-			}
-
-			// pop the child from the list
-			auto child = std::move(*child_iter);
-			children.erase(child_iter);
-
-			// expand the branch in the appropriate way
-			if (Either* either = dynamic_cast<Either*>(child.get())) {
-				// "[e] + children" for each child 'e' in Either
-				for(auto const& eitherChild : either->children()) {
-					PatternList group = { eitherChild };
-					group.insert(group.end(), children.begin(), children.end());
-
-					groups.emplace_back(std::move(group));
-				}
-			} else if (OneOrMore* oneOrMore = dynamic_cast<OneOrMore*>(child.get())) {
-				// child.children * 2 + children
-				auto const& subchildren = oneOrMore->children();
-				PatternList group = subchildren;
-				group.insert(group.end(), subchildren.begin(), subchildren.end());
-				group.insert(group.end(), children.begin(), children.end());
-
-				groups.emplace_back(std::move(group));
-			} else { // Required, Optional, OptionsShortcut
-				BranchPattern* branch = dynamic_cast<BranchPattern*>(child.get());
-
-				// child.children + children
-				PatternList group = branch->children();
-				group.insert(group.end(), children.begin(), children.end());
-
-				groups.emplace_back(std::move(group));
-			}
-		}
-
-		return result;
-	}
-
-	inline void BranchPattern::fix_repeating_arguments()
-	{
-		std::vector<PatternList> either = transform(children());
-		for(auto const& group : either) {
-			// use multiset to help identify duplicate entries
-			std::unordered_multiset<std::shared_ptr<Pattern>, PatternHasher> group_set {group.begin(), group.end()};
-			for(auto const& e : group_set) {
-				if (group_set.count(e) == 1)
-					continue;
-
-				LeafPattern* leaf = dynamic_cast<LeafPattern*>(e.get());
-				if (!leaf) continue;
-
-				bool ensureList = false;
-				bool ensureInt = false;
-
-				if (dynamic_cast<Command*>(leaf)) {
-					ensureInt = true;
-				} else if (dynamic_cast<Argument*>(leaf)) {
-					ensureList = true;
-				} else if (Option* o = dynamic_cast<Option*>(leaf)) {
-					if (o->argCount()) {
-						ensureList = true;
-					} else {
-						ensureInt = true;
-					}
-				}
-
-				if (ensureList) {
-					std::vector<std::string> newValue;
-					if (leaf->getValue().isString()) {
-						newValue = split(leaf->getValue().asString());
-					}
-					if (!leaf->getValue().isStringList()) {
-						leaf->setValue(value{newValue});
-					}
-				} else if (ensureInt) {
-					leaf->setValue(value{0});
-				}
-			}
-		}
-	}
-
-	inline bool LeafPattern::match(PatternList& left, std::vector<std::shared_ptr<LeafPattern>>& collected) const
-	{
-		auto match = single_match(left);
-		if (!match.second) {
-			return false;
-		}
-
-		left.erase(left.begin()+static_cast<std::ptrdiff_t>(match.first));
-
-		auto same_name = std::find_if(collected.begin(), collected.end(), [&](std::shared_ptr<LeafPattern> const& p) {
-			return p->name()==name();
-		});
-		if (getValue().isLong()) {
-			long val = 1;
-			if (same_name == collected.end()) {
-				collected.push_back(match.second);
-				match.second->setValue(value{val});
-			} else if ((**same_name).getValue().isLong()) {
-				val += (**same_name).getValue().asLong();
-				(**same_name).setValue(value{val});
-			} else {
-				(**same_name).setValue(value{val});
-			}
-		} else if (getValue().isStringList()) {
-			std::vector<std::string> val;
-			if (match.second->getValue().isString()) {
-				val.push_back(match.second->getValue().asString());
-			} else if (match.second->getValue().isStringList()) {
-				val = match.second->getValue().asStringList();
-			} else {
-				/// cant be!?
-			}
-
-			if (same_name == collected.end()) {
-				collected.push_back(match.second);
-				match.second->setValue(value{val});
-			} else if ((**same_name).getValue().isStringList()) {
-				std::vector<std::string> const& list = (**same_name).getValue().asStringList();
-				val.insert(val.begin(), list.begin(), list.end());
-				(**same_name).setValue(value{val});
-			} else {
-				(**same_name).setValue(value{val});
-			}
-		} else {
-			collected.push_back(match.second);
-		}
-		return true;
-	}
-
-	inline std::pair<size_t, std::shared_ptr<LeafPattern>> Argument::single_match(PatternList const& left) const
-	{
-		std::pair<size_t, std::shared_ptr<LeafPattern>> ret {};
-
-		for(size_t i = 0, size = left.size(); i < size; ++i)
-		{
-			auto arg = dynamic_cast<Argument const*>(left[i].get());
-			if (arg) {
-				ret.first = i;
-				ret.second = std::make_shared<Argument>(name(), arg->getValue());
-				break;
-			}
-		}
-
-		return ret;
-	}
-
-	inline std::pair<size_t, std::shared_ptr<LeafPattern>> Command::single_match(PatternList const& left) const
-	{
-		std::pair<size_t, std::shared_ptr<LeafPattern>> ret {};
-
-		for(size_t i = 0, size = left.size(); i < size; ++i)
-		{
-			auto arg = dynamic_cast<Argument const*>(left[i].get());
-			if (arg) {
-				if (name() == arg->getValue()) {
-					ret.first = i;
-					ret.second = std::make_shared<Command>(name(), value{true});
-				}
-				break;
-			}
-		}
-
-		return ret;
-	}
-
-	inline Option Option::parse(std::string const& option_description)
-	{
-		std::string shortOption, longOption;
-		int argcount = 0;
-		value val { false };
-
-		auto double_space = option_description.find("  ");
-		auto options_end = option_description.end();
-		if (double_space != std::string::npos) {
-			options_end = option_description.begin() + static_cast<std::ptrdiff_t>(double_space);
-		}
-
-		static const std::regex pattern {"(-{1,2})?(.*?)([,= ]|$)"};
-		for(std::sregex_iterator i {option_description.begin(), options_end, pattern, std::regex_constants::match_not_null},
-			   e{};
-			i != e;
-			++i)
-		{
-			std::smatch const& match = *i;
-			if (match[1].matched) { // [1] is optional.
-				if (match[1].length()==1) {
-						shortOption = "-" + match[2].str();
-				} else {
-						longOption =  "--" + match[2].str();
-				}
-			} else if (match[2].length() > 0) { // [2] always matches.
-				std::string m = match[2];
-				argcount = 1;
-			} else {
-				// delimeter
-			}
-
-			if (match[3].length() == 0) { // [3] always matches.
-				// Hit end of string. For some reason 'match_not_null' will let us match empty
-				// at the end, and then we'll spin in an infinite loop. So, if we hit an empty
-				// match, we know we must be at the end.
-				break;
-			}
-		}
-
-		if (argcount) {
-			std::smatch match;
-			if (std::regex_search(options_end, option_description.end(),
-						  match,
-						  std::regex{"\\[default: (.*)\\]", std::regex::icase}))
-			{
-				val = match[1].str();
-			}
-		}
-
-		return {std::move(shortOption),
-			std::move(longOption),
-			argcount,
-			std::move(val)};
-	}
-
-	inline std::pair<size_t, std::shared_ptr<LeafPattern>> Option::single_match(PatternList const& left) const
-	{
-		auto thematch = find_if(left.begin(), left.end(), [this](std::shared_ptr<Pattern> const& a) {
-			auto leaf = std::dynamic_pointer_cast<LeafPattern>(a);
-			return leaf && this->name() == leaf->name();
-		});
-		if (thematch == left.end()) {
-			return {};
-		}
-		return { std::distance(left.begin(), thematch), std::dynamic_pointer_cast<LeafPattern>(*thematch) };
-	}
-
-	inline bool Required::match(PatternList& left, std::vector<std::shared_ptr<LeafPattern>>& collected) const {
-		auto l = left;
-		auto c = collected;
-		for(auto const& pattern : fChildren) {
-			bool ret = pattern->match(l, c);
-			if (!ret) {
-				// leave (left, collected) untouched
-				return false;
-			}
-		}
-
-		left = std::move(l);
-		collected = std::move(c);
-		return true;
-	}
-
-	inline bool OneOrMore::match(PatternList& left, std::vector<std::shared_ptr<LeafPattern>>& collected) const
-	{
-		assert(fChildren.size() == 1);
-
-		auto l = left;
-		auto c = collected;
-
-		bool matched = true;
-		size_t times = 0;
-
-		decltype(l) l_;
-		bool firstLoop = true;
-
-		while (matched) {
-			// could it be that something didn't match but changed l or c?
-			matched = fChildren[0]->match(l, c);
-
-			if (matched)
-				++times;
-
-			if (firstLoop) {
-				firstLoop = false;
-			} else if (l == l_) {
-				break;
-			}
-
-			l_ = l;
-		}
-
-		if (times == 0) {
-			return false;
-		}
-
-		left = std::move(l);
-		collected = std::move(c);
-		return true;
-	}
-
-	inline bool Either::match(PatternList& left, std::vector<std::shared_ptr<LeafPattern>>& collected) const
-	{
-		using Outcome = std::pair<PatternList, std::vector<std::shared_ptr<LeafPattern>>>;
-
-		std::vector<Outcome> outcomes;
-
-		for(auto const& pattern : fChildren) {
-			// need a copy so we apply the same one for every iteration
-			auto l = left;
-			auto c = collected;
-			bool matched = pattern->match(l, c);
-			if (matched) {
-				outcomes.emplace_back(std::move(l), std::move(c));
-			}
-		}
-
-		auto min = std::min_element(outcomes.begin(), outcomes.end(), [](Outcome const& o1, Outcome const& o2) {
-			return o1.first.size() < o2.first.size();
-		});
-
-		if (min == outcomes.end()) {
-			// (left, collected) unchanged
-			return false;
-		}
-
-		std::tie(left, collected) = std::move(*min);
-		return true;
-	}
-
-}
-
-#endif
diff --git a/a/docopt_util.h b/a/docopt_util.h
deleted file mode 100644
index b504609..0000000
--- a/a/docopt_util.h
+++ /dev/null
@@ -1,122 +0,0 @@
-//
-//  docopt_util.h
-//  docopt
-//
-//  Created by Jared Grubb on 2013-11-04.
-//  Copyright (c) 2013 Jared Grubb. All rights reserved.
-//
-
-#ifndef docopt_docopt_util_h
-#define docopt_docopt_util_h
-
-#if DOCTOPT_USE_BOOST_REGEX
-#include <boost/regex.hpp>
-namespace std {
-    using boost::regex;
-    using boost::sregex_token_iterator;
-}
-#else
-#include <regex>
-#endif
-
-#if 0
-#pragma mark -
-#pragma mark General utility
-#endif
-
-namespace {
-	bool starts_with(std::string const& str, std::string const& prefix)
-	{
-		if (str.length() < prefix.length())
-			return false;
-		return std::equal(prefix.begin(), prefix.end(),
-				  str.begin());
-	}
-
-	std::string trim(std::string&& str,
-			 const std::string& whitespace = " \t\n")
-	{
-		const auto strEnd = str.find_last_not_of(whitespace);
-		if (strEnd==std::string::npos)
-			return {}; // no content
-		str.erase(strEnd+1);
-
-		const auto strBegin = str.find_first_not_of(whitespace);
-		str.erase(0, strBegin);
-
-		return std::move(str);
-	}
-
-	std::vector<std::string> split(std::string const& str, size_t pos = 0)
-	{
-		const char* const anySpace = " \t\r\n\v\f";
-
-		std::vector<std::string> ret;
-		while (pos != std::string::npos) {
-			auto start = str.find_first_not_of(anySpace, pos);
-			if (start == std::string::npos) break;
-
-			auto end = str.find_first_of(anySpace, start);
-			auto size = end==std::string::npos ? end : end-start;
-			ret.emplace_back(str.substr(start, size));
-
-			pos = end;
-		}
-
-		return ret;
-	}
-
-	std::tuple<std::string, std::string, std::string> partition(std::string str, std::string const& point)
-	{
-		std::tuple<std::string, std::string, std::string> ret;
-
-		auto i = str.find(point);
-
-		if (i == std::string::npos) {
-			// no match: string goes in 0th spot only
-		} else {
-			std::get<2>(ret) = str.substr(i + point.size());
-			std::get<1>(ret) = point;
-			str.resize(i);
-		}
-		std::get<0>(ret) = std::move(str);
-
-		return ret;
-	}
-
-	template <typename I>
-	std::string join(I iter, I end, std::string const& delim) {
-		if (iter==end)
-			return {};
-
-		std::string ret = *iter;
-		for(++iter; iter!=end; ++iter) {
-			ret.append(delim);
-			ret.append(*iter);
-		}
-		return ret;
-	}
-
-	std::vector<std::string> regex_split(std::string const& text, std::regex const& re)
-	{
-		std::vector<std::string> ret;
-		for (auto it = std::sregex_token_iterator(text.begin(), text.end(), re, -1);
-			it != std::sregex_token_iterator();
-			++it) {
-			ret.emplace_back(*it);
-		}
-		return ret;
-	}
-}
-
-namespace docopt {
-	template <class T>
-	inline void hash_combine(std::size_t& seed, T const& v)
-	{
-		// stolen from boost::hash_combine
-		std::hash<T> hasher;
-		seed ^= hasher(v) + 0x9e3779b9 + (seed<<6) + (seed>>2);
-	}
-}
-
-#endif
diff --git a/a/docopt_value.h b/a/docopt_value.h
deleted file mode 100644
index e1c87e6..0000000
--- a/a/docopt_value.h
+++ /dev/null
@@ -1,341 +0,0 @@
-//
-//  value.h
-//  docopt
-//
-//  Created by Jared Grubb on 2013-10-14.
-//  Copyright (c) 2013 Jared Grubb. All rights reserved.
-//
-
-#ifndef docopt__value_h_
-#define docopt__value_h_
-
-#include <string>
-#include <vector>
-#include <functional> // std::hash
-#include <iosfwd>
-#include <stdexcept>
-
-namespace docopt {
-
-	enum class Kind {
-		Empty,
-		Bool,
-		Long,
-		String,
-		StringList
-	};
-
-	/// A generic type to hold the various types that can be produced by docopt.
-	///
-	/// This type can be one of: {bool, long, string, vector<string>}, or empty.
-	struct value {
-		/// An empty value
-		value() {}
-
-		value(std::string);
-		value(std::vector<std::string>);
-		
-		explicit value(bool);
-		explicit value(long);
-		explicit value(int v) : value(static_cast<long>(v)) {}
-
-		~value();
-		value(value const&);
-		value(value&&) noexcept;
-		value& operator=(value const&);
-		value& operator=(value&&) noexcept;
-
-		Kind kind() const { return kind_; }
-		
-		// Test if this object has any contents at all
-		explicit operator bool() const { return kind_ != Kind::Empty; }
-		
-		// Test the type contained by this value object
-		bool isBool()       const { return kind_==Kind::Bool; }
-		bool isString()     const { return kind_==Kind::String; }
-		bool isLong()       const { return kind_==Kind::Long; }
-		bool isStringList() const { return kind_==Kind::StringList; }
-
-		// Throws std::invalid_argument if the type does not match
-		bool asBool() const;
-		long asLong() const;
-		std::string const& asString() const;
-		std::vector<std::string> const& asStringList() const;
-
-		size_t hash() const noexcept;
-		
-		friend bool operator==(value const&, value const&);
-		friend bool operator!=(value const&, value const&);
-
-	private:
-		union Variant {
-			Variant() {}
-			~Variant() {  /* do nothing; will be destroyed by ~value */ }
-			
-			bool boolValue;
-			long longValue;
-			std::string strValue;
-			std::vector<std::string> strList;
-		};
-		
-		static const char* kindAsString(Kind kind) {
-			switch (kind) {
-				case Kind::Empty: return "empty";
-				case Kind::Bool: return "bool";
-				case Kind::Long: return "long";
-				case Kind::String: return "string";
-				case Kind::StringList: return "string-list";
-			}
-			return "unknown";
-		}
-
-		void throwIfNotKind(Kind expected) const {
-			if (kind_ == expected)
-				return;
-
-			std::string error = "Illegal cast to ";
-			error += kindAsString(expected);
-			error += "; type is actually ";
-			error += kindAsString(kind_);
-			throw std::runtime_error(std::move(error));
-		}
-
-		Kind kind_ = Kind::Empty;
-		Variant variant_ {};
-	};
-
-	/// Write out the contents to the ostream
-	DOCOPT_API std::ostream& operator<<(std::ostream&, value const&);
-}
-
-namespace std {
-	template <>
-	struct hash<docopt::value> {
-		size_t operator()(docopt::value const& val) const noexcept {
-			return val.hash();
-		}
-	};
-}
-
-namespace docopt {
-	inline
-	value::value(bool v)
-	: kind_(Kind::Bool)
-	{
-		variant_.boolValue = v;
-	}
-
-	inline
-	value::value(long v)
-	: kind_(Kind::Long)
-	{
-		variant_.longValue = v;
-	}
-
-	inline
-	value::value(std::string v)
-	: kind_(Kind::String)
-	{
-		new (&variant_.strValue) std::string(std::move(v));
-	}
-
-	inline
-	value::value(std::vector<std::string> v)
-	: kind_(Kind::StringList)
-	{
-		new (&variant_.strList) std::vector<std::string>(std::move(v));
-	}
-
-	inline
-	value::value(value const& other)
-	: kind_(other.kind_)
-	{
-		switch (kind_) {
-			case Kind::String:
-				new (&variant_.strValue) std::string(other.variant_.strValue);
-				break;
-
-			case Kind::StringList:
-				new (&variant_.strList) std::vector<std::string>(other.variant_.strList);
-				break;
-
-			case Kind::Bool:
-				variant_.boolValue = other.variant_.boolValue;
-				break;
-
-			case Kind::Long:
-				variant_.longValue = other.variant_.longValue;
-				break;
-
-			case Kind::Empty:
-			default:
-				break;
-		}
-	}
-
-	inline
-	value::value(value&& other) noexcept
-	: kind_(other.kind_)
-	{
-		switch (kind_) {
-			case Kind::String:
-				new (&variant_.strValue) std::string(std::move(other.variant_.strValue));
-				break;
-
-			case Kind::StringList:
-				new (&variant_.strList) std::vector<std::string>(std::move(other.variant_.strList));
-				break;
-
-			case Kind::Bool:
-				variant_.boolValue = other.variant_.boolValue;
-				break;
-
-			case Kind::Long:
-				variant_.longValue = other.variant_.longValue;
-				break;
-
-			case Kind::Empty:
-			default:
-				break;
-		}
-	}
-
-	inline
-	value::~value()
-	{
-		switch (kind_) {
-			case Kind::String:
-				variant_.strValue.~basic_string();
-				break;
-
-			case Kind::StringList:
-				variant_.strList.~vector();
-				break;
-
-			case Kind::Empty:
-			case Kind::Bool:
-			case Kind::Long:
-			default:
-				// trivial dtor
-				break;
-		}
-	}
-
-	inline
-	value& value::operator=(value const& other) {
-		// make a copy and move from it; way easier.
-		return *this = value{other};
-	}
-
-	inline
-	value& value::operator=(value&& other) noexcept {
-		// move of all the types involved is noexcept, so we dont have to worry about 
-		// these two statements throwing, which gives us a consistency guarantee.
-		this->~value();
-		new (this) value(std::move(other));
-
-		return *this;
-	}
-
-	template <class T>
-	void hash_combine(std::size_t& seed, const T& v);
-
-	inline
-	size_t value::hash() const noexcept
-	{
-		switch (kind_) {
-			case Kind::String:
-				return std::hash<std::string>()(variant_.strValue);
-
-			case Kind::StringList: {
-				size_t seed = std::hash<size_t>()(variant_.strList.size());
-				for(auto const& str : variant_.strList) {
-					hash_combine(seed, str);
-				}
-				return seed;
-			}
-
-			case Kind::Bool:
-				return std::hash<bool>()(variant_.boolValue);
-
-			case Kind::Long:
-				return std::hash<long>()(variant_.longValue);
-
-			case Kind::Empty:
-			default:
-				return std::hash<void*>()(nullptr);
-		}
-	}
-
-	inline
-	bool value::asBool() const
-	{
-		throwIfNotKind(Kind::Bool);
-		return variant_.boolValue;
-	}
-
-	inline
-	long value::asLong() const
-	{
-		// Attempt to convert a string to a long
-		if (kind_ == Kind::String) {
-			const std::string& str = variant_.strValue;
-			std::size_t pos;
-			const long ret = stol(str, &pos); // Throws if it can't convert
-			if (pos != str.length()) {
-				// The string ended in non-digits.
-				throw std::runtime_error( str + " contains non-numeric characters.");
-			}
-			return ret;
-		}
-		throwIfNotKind(Kind::Long);
-		return variant_.longValue;
-	}
-
-	inline
-	std::string const& value::asString() const
-	{
-		throwIfNotKind(Kind::String);
-		return variant_.strValue;
-	}
-
-	inline
-	std::vector<std::string> const& value::asStringList() const
-	{
-		throwIfNotKind(Kind::StringList);
-		return variant_.strList;
-	}
-
-	inline
-	bool operator==(value const& v1, value const& v2)
-	{
-		if (v1.kind_ != v2.kind_)
-			return false;
-		
-		switch (v1.kind_) {
-			case Kind::String:
-				return v1.variant_.strValue==v2.variant_.strValue;
-
-			case Kind::StringList:
-				return v1.variant_.strList==v2.variant_.strList;
-
-			case Kind::Bool:
-				return v1.variant_.boolValue==v2.variant_.boolValue;
-
-			case Kind::Long:
-				return v1.variant_.longValue==v2.variant_.longValue;
-
-			case Kind::Empty:
-			default:
-				return true;
-		}
-	}
-
-	inline
-	bool operator!=(value const& v1, value const& v2)
-	{
-		return !(v1 == v2);
-	}
-}
-
-#endif /* defined(docopt__value_h_) */
diff --git a/a/examples/naval_fate.cpp b/a/examples/naval_fate.cpp
deleted file mode 100644
index 36dbf2e..0000000
--- a/a/examples/naval_fate.cpp
+++ /dev/null
@@ -1,36 +0,0 @@
-#include "docopt.h"
-
-#include <iostream>
-
-static const char USAGE[] =
-R"(Naval Fate.
-
-    Usage:
-      naval_fate ship new <name>...
-      naval_fate ship <name> move <x> <y> [--speed=<kn>]
-      naval_fate ship shoot <x> <y>
-      naval_fate mine (set|remove) <x> <y> [--moored | --drifting]
-      naval_fate (-h | --help)
-      naval_fate --version
-
-    Options:
-      -h --help     Show this screen.
-      --version     Show version.
-      --speed=<kn>  Speed in knots [default: 10].
-      --moored      Moored (anchored) mine.
-      --drifting    Drifting mine.
-)";
-
-int main(int argc, const char** argv)
-{
-    std::map<std::string, docopt::value> args = docopt::docopt(USAGE, 
-                                                  { argv + 1, argv + argc },
-                                                  true,               // show help if requested
-                                                  "Naval Fate 2.0");  // version string
-
-    for(auto const& arg : args) {
-        std::cout << arg.first << ": " << arg.second << std::endl;
-    }
-
-    return 0;
-}
diff --git a/a/main.cpp b/a/main.cpp
deleted file mode 100644
index 4127d9f..0000000
--- a/a/main.cpp
+++ /dev/null
@@ -1,16 +0,0 @@
-//
-//  main.cpp
-//  docopt
-//
-//  Created by Jared Grubb on 2013-10-03.
-//  Copyright (c) 2013 Jared Grubb. All rights reserved.
-//
-
-#include "docopt.h"
-
-int main(int argc, const char * argv[])
-{
-	
-	return 0;
-}
-
diff --git a/a/run_testcase.cpp b/a/run_testcase.cpp
deleted file mode 100644
index 2ed9b65..0000000
--- a/a/run_testcase.cpp
+++ /dev/null
@@ -1,40 +0,0 @@
-//
-//  docopt_tests.cpp
-//  docopt
-//
-//  Created by Jared Grubb on 2013-11-03.
-//  Copyright (c) 2013 Jared Grubb. All rights reserved.
-//
-
-#include "docopt.h"
-
-#include <iostream>
-
-int main(int argc, const char** argv)
-{
-	if (argc < 2) {
-		std::cerr << "Usage: docopt_tests USAGE [arg]..." << std::endl;
-		exit(-5);
-	}
-	
-	std::string usage = argv[1];
-	std::vector<std::string> args {argv+2, argv+argc};
-	
-	auto result = docopt::docopt(usage, args);
-
-	// print it out in JSON form
-	std::cout << "{ ";
-	bool first = true;
-	for(auto const& arg : result) {
-		if (first) {
-			first = false;
-		} else {
-			std::cout << "," << std::endl;
-		}
-		
-		std::cout << '"' << arg.first << '"' << ": " << arg.second;
-	}
-	std::cout << " }" << std::endl;
-
-	return 0;
-}
\ No newline at end of file
diff --git a/a/run_tests.py b/a/run_tests.py
deleted file mode 100644
index b75e176..0000000
--- a/a/run_tests.py
+++ /dev/null
@@ -1,72 +0,0 @@
-#!/usr/bin/env python3
-
-import re
-import sys
-import json
-import subprocess
-
-executable = "${TESTPROG}"
-
-def parse_test(raw):
-	raw = re.compile('#.*$', re.M).sub('', raw).strip()
-	if raw.startswith('"""'):
-		raw = raw[3:]
-
-	for fixture in raw.split('r"""'):
-		name = ''
-		doc, _, body = fixture.partition('"""')
-		cases = []
-		for case in body.split('$')[1:]:
-			argv, _, expect = case.strip().partition('\n')
-			expect = json.loads(expect)
-			prog, _, argv = argv.strip().partition(' ')
-			cases.append((prog, argv, expect))
-
-		yield name, doc, cases
-
-failures = 0
-passes = 0
-
-tests = open('${TESTCASES}','r').read()
-for _, doc, cases in parse_test(tests):
-	if not cases: continue
-
-	for prog, argv, expect in cases:
-		args = [ x for x in argv.split() if x ]
-
-		expect_error = not isinstance(expect, dict)
-
-		error = None
-		out = None
-		try:
-			out = subprocess.check_output([executable, doc]+args, stderr=subprocess.STDOUT)
-			if expect_error:
-				error = " ** an error was expected but it appeared to succeed!"
-			else:
-				json_out = json.loads(out)
-				if expect != json_out:
-					error = " ** JSON does not match expected: %r" % expect
-		except subprocess.CalledProcessError as e:
-			if not expect_error:
-				error = "\n ** this should have succeeded! exit code = %s" % e.returncode
-
-		if not error:
-			passes += 1
-			continue
-
-		failures += 1
-
-		print("="*40)
-		print(doc)
-		print(':'*20)
-		print(prog, argv)
-		print('-'*20)
-		if out:
-			print(out)
-		print(error)
-
-if failures:
-	print("%d failures" % failures)
-	sys.exit(1)
-else:
-	print("PASS (%d)" % passes)
diff --git a/a/testcases.docopt b/a/testcases.docopt
deleted file mode 100644
index efe9a07..0000000
--- a/a/testcases.docopt
+++ /dev/null
@@ -1,957 +0,0 @@
-r"""Usage: prog
-
-"""
-$ prog
-{}
-
-$ prog --xxx
-"user-error"
-
-
-r"""Usage: prog [options]
-
-Options: -a  All.
-
-"""
-$ prog
-{"-a": false}
-
-$ prog -a
-{"-a": true}
-
-$ prog -x
-"user-error"
-
-
-r"""Usage: prog [options]
-
-Options: --all  All.
-
-"""
-$ prog
-{"--all": false}
-
-$ prog --all
-{"--all": true}
-
-$ prog --xxx
-"user-error"
-
-
-r"""Usage: prog [options]
-
-Options: -v, --verbose  Verbose.
-
-"""
-$ prog --verbose
-{"--verbose": true}
-
-$ prog --ver
-{"--verbose": true}
-
-$ prog -v
-{"--verbose": true}
-
-
-r"""Usage: prog [options]
-
-Options: -p PATH
-
-"""
-$ prog -p home/
-{"-p": "home/"}
-
-$ prog -phome/
-{"-p": "home/"}
-
-$ prog -p
-"user-error"
-
-
-r"""Usage: prog [options]
-
-Options: --path <path>
-
-"""
-$ prog --path home/
-{"--path": "home/"}
-
-$ prog --path=home/
-{"--path": "home/"}
-
-$ prog --pa home/
-{"--path": "home/"}
-
-$ prog --pa=home/
-{"--path": "home/"}
-
-$ prog --path
-"user-error"
-
-
-r"""Usage: prog [options]
-
-Options: -p PATH, --path=<path>  Path to files.
-
-"""
-$ prog -proot
-{"--path": "root"}
-
-
-r"""Usage: prog [options]
-
-Options:    -p --path PATH  Path to files.
-
-"""
-$ prog -p root
-{"--path": "root"}
-
-$ prog --path root
-{"--path": "root"}
-
-
-r"""Usage: prog [options]
-
-Options:
- -p PATH  Path to files [default: ./]
-
-"""
-$ prog
-{"-p": "./"}
-
-$ prog -phome
-{"-p": "home"}
-
-
-r"""UsAgE: prog [options]
-
-OpTiOnS: --path=<files>  Path to files
-                [dEfAuLt: /root]
-
-"""
-$ prog
-{"--path": "/root"}
-
-$ prog --path=home
-{"--path": "home"}
-
-
-r"""usage: prog [options]
-
-options:
-    -a        Add
-    -r        Remote
-    -m <msg>  Message
-
-"""
-$ prog -a -r -m Hello
-{"-a": true,
- "-r": true,
- "-m": "Hello"}
-
-$ prog -armyourass
-{"-a": true,
- "-r": true,
- "-m": "yourass"}
-
-$ prog -a -r
-{"-a": true,
- "-r": true,
- "-m": null}
-
-
-r"""Usage: prog [options]
-
-Options: --version
-         --verbose
-
-"""
-$ prog --version
-{"--version": true,
- "--verbose": false}
-
-$ prog --verbose
-{"--version": false,
- "--verbose": true}
-
-$ prog --ver
-"user-error"
-
-$ prog --verb
-{"--version": false,
- "--verbose": true}
-
-
-r"""usage: prog [-a -r -m <msg>]
-
-options:
- -a        Add
- -r        Remote
- -m <msg>  Message
-
-"""
-$ prog -armyourass
-{"-a": true,
- "-r": true,
- "-m": "yourass"}
-
-
-r"""usage: prog [-armmsg]
-
-options: -a        Add
-         -r        Remote
-         -m <msg>  Message
-
-"""
-$ prog -a -r -m Hello
-{"-a": true,
- "-r": true,
- "-m": "Hello"}
-
-
-r"""usage: prog -a -b
-
-options:
- -a
- -b
-
-"""
-$ prog -a -b
-{"-a": true, "-b": true}
-
-$ prog -b -a
-{"-a": true, "-b": true}
-
-$ prog -a
-"user-error"
-
-$ prog
-"user-error"
-
-
-r"""usage: prog (-a -b)
-
-options: -a
-         -b
-
-"""
-$ prog -a -b
-{"-a": true, "-b": true}
-
-$ prog -b -a
-{"-a": true, "-b": true}
-
-$ prog -a
-"user-error"
-
-$ prog
-"user-error"
-
-
-r"""usage: prog [-a] -b
-
-options: -a
- -b
-
-"""
-$ prog -a -b
-{"-a": true, "-b": true}
-
-$ prog -b -a
-{"-a": true, "-b": true}
-
-$ prog -a
-"user-error"
-
-$ prog -b
-{"-a": false, "-b": true}
-
-$ prog
-"user-error"
-
-
-r"""usage: prog [(-a -b)]
-
-options: -a
-         -b
-
-"""
-$ prog -a -b
-{"-a": true, "-b": true}
-
-$ prog -b -a
-{"-a": true, "-b": true}
-
-$ prog -a
-"user-error"
-
-$ prog -b
-"user-error"
-
-$ prog
-{"-a": false, "-b": false}
-
-
-r"""usage: prog (-a|-b)
-
-options: -a
-         -b
-
-"""
-$ prog -a -b
-"user-error"
-
-$ prog
-"user-error"
-
-$ prog -a
-{"-a": true, "-b": false}
-
-$ prog -b
-{"-a": false, "-b": true}
-
-
-r"""usage: prog [ -a | -b ]
-
-options: -a
-         -b
-
-"""
-$ prog -a -b
-"user-error"
-
-$ prog
-{"-a": false, "-b": false}
-
-$ prog -a
-{"-a": true, "-b": false}
-
-$ prog -b
-{"-a": false, "-b": true}
-
-
-r"""usage: prog <arg>"""
-$ prog 10
-{"<arg>": "10"}
-
-$ prog 10 20
-"user-error"
-
-$ prog
-"user-error"
-
-
-r"""usage: prog [<arg>]"""
-$ prog 10
-{"<arg>": "10"}
-
-$ prog 10 20
-"user-error"
-
-$ prog
-{"<arg>": null}
-
-
-r"""usage: prog <kind> <name> <type>"""
-$ prog 10 20 40
-{"<kind>": "10", "<name>": "20", "<type>": "40"}
-
-$ prog 10 20
-"user-error"
-
-$ prog
-"user-error"
-
-
-r"""usage: prog <kind> [<name> <type>]"""
-$ prog 10 20 40
-{"<kind>": "10", "<name>": "20", "<type>": "40"}
-
-$ prog 10 20
-{"<kind>": "10", "<name>": "20", "<type>": null}
-
-$ prog
-"user-error"
-
-
-r"""usage: prog [<kind> | <name> <type>]"""
-$ prog 10 20 40
-"user-error"
-
-$ prog 20 40
-{"<kind>": null, "<name>": "20", "<type>": "40"}
-
-$ prog
-{"<kind>": null, "<name>": null, "<type>": null}
-
-
-r"""usage: prog (<kind> --all | <name>)
-
-options:
- --all
-
-"""
-$ prog 10 --all
-{"<kind>": "10", "--all": true, "<name>": null}
-
-$ prog 10
-{"<kind>": null, "--all": false, "<name>": "10"}
-
-$ prog
-"user-error"
-
-
-r"""usage: prog [<name> <name>]"""
-$ prog 10 20
-{"<name>": ["10", "20"]}
-
-$ prog 10
-{"<name>": ["10"]}
-
-$ prog
-{"<name>": []}
-
-
-r"""usage: prog [(<name> <name>)]"""
-$ prog 10 20
-{"<name>": ["10", "20"]}
-
-$ prog 10
-"user-error"
-
-$ prog
-{"<name>": []}
-
-
-r"""usage: prog NAME..."""
-$ prog 10 20
-{"NAME": ["10", "20"]}
-
-$ prog 10
-{"NAME": ["10"]}
-
-$ prog
-"user-error"
-
-
-r"""usage: prog [NAME]..."""
-$ prog 10 20
-{"NAME": ["10", "20"]}
-
-$ prog 10
-{"NAME": ["10"]}
-
-$ prog
-{"NAME": []}
-
-
-r"""usage: prog [NAME...]"""
-$ prog 10 20
-{"NAME": ["10", "20"]}
-
-$ prog 10
-{"NAME": ["10"]}
-
-$ prog
-{"NAME": []}
-
-
-r"""usage: prog [NAME [NAME ...]]"""
-$ prog 10 20
-{"NAME": ["10", "20"]}
-
-$ prog 10
-{"NAME": ["10"]}
-
-$ prog
-{"NAME": []}
-
-
-r"""usage: prog (NAME | --foo NAME)
-
-options: --foo
-
-"""
-$ prog 10
-{"NAME": "10", "--foo": false}
-
-$ prog --foo 10
-{"NAME": "10", "--foo": true}
-
-$ prog --foo=10
-"user-error"
-
-
-r"""usage: prog (NAME | --foo) [--bar | NAME]
-
-options: --foo
-options: --bar
-
-"""
-$ prog 10
-{"NAME": ["10"], "--foo": false, "--bar": false}
-
-$ prog 10 20
-{"NAME": ["10", "20"], "--foo": false, "--bar": false}
-
-$ prog --foo --bar
-{"NAME": [], "--foo": true, "--bar": true}
-
-
-r"""Naval Fate.
-
-Usage:
-  prog ship new <name>...
-  prog ship [<name>] move <x> <y> [--speed=<kn>]
-  prog ship shoot <x> <y>
-  prog mine (set|remove) <x> <y> [--moored|--drifting]
-  prog -h | --help
-  prog --version
-
-Options:
-  -h --help     Show this screen.
-  --version     Show version.
-  --speed=<kn>  Speed in knots [default: 10].
-  --moored      Mored (anchored) mine.
-  --drifting    Drifting mine.
-
-"""
-$ prog ship Guardian move 150 300 --speed=20
-{"--drifting": false,
- "--help": false,
- "--moored": false,
- "--speed": "20",
- "--version": false,
- "<name>": ["Guardian"],
- "<x>": "150",
- "<y>": "300",
- "mine": false,
- "move": true,
- "new": false,
- "remove": false,
- "set": false,
- "ship": true,
- "shoot": false}
-
-
-r"""usage: prog --hello"""
-$ prog --hello
-{"--hello": true}
-
-
-r"""usage: prog [--hello=<world>]"""
-$ prog
-{"--hello": null}
-
-$ prog --hello wrld
-{"--hello": "wrld"}
-
-
-r"""usage: prog [-o]"""
-$ prog
-{"-o": false}
-
-$ prog -o
-{"-o": true}
-
-
-r"""usage: prog [-opr]"""
-$ prog -op
-{"-o": true, "-p": true, "-r": false}
-
-
-r"""usage: prog --aabb | --aa"""
-$ prog --aa
-{"--aabb": false, "--aa": true}
-
-$ prog --a
-"user-error"  # not a unique prefix
-
-#
-# Counting number of flags
-#
-
-r"""Usage: prog -v"""
-$ prog -v
-{"-v": true}
-
-
-r"""Usage: prog [-v -v]"""
-$ prog
-{"-v": 0}
-
-$ prog -v
-{"-v": 1}
-
-$ prog -vv
-{"-v": 2}
-
-
-r"""Usage: prog -v ..."""
-$ prog
-"user-error"
-
-$ prog -v
-{"-v": 1}
-
-$ prog -vv
-{"-v": 2}
-
-$ prog -vvvvvv
-{"-v": 6}
-
-
-r"""Usage: prog [-v | -vv | -vvv]
-
-This one is probably most readable user-friednly variant.
-
-"""
-$ prog
-{"-v": 0}
-
-$ prog -v
-{"-v": 1}
-
-$ prog -vv
-{"-v": 2}
-
-$ prog -vvvv
-"user-error"
-
-
-r"""usage: prog [--ver --ver]"""
-$ prog --ver --ver
-{"--ver": 2}
-
-
-#
-# Counting commands
-#
-
-r"""usage: prog [go]"""
-$ prog go
-{"go": true}
-
-
-r"""usage: prog [go go]"""
-$ prog
-{"go": 0}
-
-$ prog go
-{"go": 1}
-
-$ prog go go
-{"go": 2}
-
-$ prog go go go
-"user-error"
-
-r"""usage: prog go..."""
-$ prog go go go go go
-{"go": 5}
-
-#
-# [options] does not include options from usage-pattern
-#
-r"""usage: prog [options] [-a]
-
-options: -a
-         -b
-"""
-$ prog -a
-{"-a": true, "-b": false}
-
-$ prog -aa
-"user-error"
-
-#
-# Test [options] shourtcut
-#
-
-r"""Usage: prog [options] A
-Options:
-    -q  Be quiet
-    -v  Be verbose.
-
-"""
-$ prog arg
-{"A": "arg", "-v": false, "-q": false}
-
-$ prog -v arg
-{"A": "arg", "-v": true, "-q": false}
-
-$ prog -q arg
-{"A": "arg", "-v": false, "-q": true}
-
-#
-# Test single dash
-#
-
-r"""usage: prog [-]"""
-
-$ prog -
-{"-": true}
-
-$ prog
-{"-": false}
-
-#
-# If argument is repeated, its value should always be a list
-#
-
-r"""usage: prog [NAME [NAME ...]]"""
-
-$ prog a b
-{"NAME": ["a", "b"]}
-
-$ prog
-{"NAME": []}
-
-#
-# Option's argument defaults to null/None
-#
-
-r"""usage: prog [options]
-options:
- -a        Add
- -m <msg>  Message
-
-"""
-$ prog -a
-{"-m": null, "-a": true}
-
-#
-# Test options without description
-#
-
-r"""usage: prog --hello"""
-$ prog --hello
-{"--hello": true}
-
-r"""usage: prog [--hello=<world>]"""
-$ prog
-{"--hello": null}
-
-$ prog --hello wrld
-{"--hello": "wrld"}
-
-r"""usage: prog [-o]"""
-$ prog
-{"-o": false}
-
-$ prog -o
-{"-o": true}
-
-r"""usage: prog [-opr]"""
-$ prog -op
-{"-o": true, "-p": true, "-r": false}
-
-r"""usage: git [-v | --verbose]"""
-$ prog -v
-{"-v": true, "--verbose": false}
-
-r"""usage: git remote [-v | --verbose]"""
-$ prog remote -v
-{"remote": true, "-v": true, "--verbose": false}
-
-#
-# Test empty usage pattern
-#
-
-r"""usage: prog"""
-$ prog
-{}
-
-r"""usage: prog
-           prog <a> <b>
-"""
-$ prog 1 2
-{"<a>": "1", "<b>": "2"}
-
-$ prog
-{"<a>": null, "<b>": null}
-
-r"""usage: prog <a> <b>
-           prog
-"""
-$ prog
-{"<a>": null, "<b>": null}
-
-#
-# Option's argument should not capture default value from usage pattern
-#
-
-r"""usage: prog [--file=<f>]"""
-$ prog
-{"--file": null}
-
-r"""usage: prog [--file=<f>]
-
-options: --file <a>
-
-"""
-$ prog
-{"--file": null}
-
-r"""Usage: prog [-a <host:port>]
-
-Options: -a, --address <host:port>  TCP address [default: localhost:6283].
-
-"""
-$ prog
-{"--address": "localhost:6283"}
-
-#
-# If option with argument could be repeated,
-# its arguments should be accumulated into a list
-#
-
-r"""usage: prog --long=<arg> ..."""
-
-$ prog --long one
-{"--long": ["one"]}
-
-$ prog --long one --long two
-{"--long": ["one", "two"]}
-
-#
-# Test multiple elements repeated at once
-#
-
-r"""usage: prog (go <direction> --speed=<km/h>)..."""
-$ prog  go left --speed=5  go right --speed=9
-{"go": 2, "<direction>": ["left", "right"], "--speed": ["5", "9"]}
-
-#
-# Required options should work with option shortcut
-#
-
-r"""usage: prog [options] -a
-
-options: -a
-
-"""
-$ prog -a
-{"-a": true}
-
-#
-# If option could be repeated its defaults should be split into a list
-#
-
-r"""usage: prog [-o <o>]...
-
-options: -o <o>  [default: x]
-
-"""
-$ prog -o this -o that
-{"-o": ["this", "that"]}
-
-$ prog
-{"-o": ["x"]}
-
-r"""usage: prog [-o <o>]...
-
-options: -o <o>  [default: x y]
-
-"""
-$ prog -o this
-{"-o": ["this"]}
-
-$ prog
-{"-o": ["x", "y"]}
-
-#
-# Test stacked option's argument
-#
-
-r"""usage: prog -pPATH
-
-options: -p PATH
-
-"""
-$ prog -pHOME
-{"-p": "HOME"}
-
-#
-# Issue 56: Repeated mutually exclusive args give nested lists sometimes
-#
-
-r"""Usage: foo (--xx=x|--yy=y)..."""
-$ prog --xx=1 --yy=2
-{"--xx": ["1"], "--yy": ["2"]}
-
-#
-# POSIXly correct tokenization
-#
-
-r"""usage: prog [<input file>]"""
-$ prog f.txt
-{"<input file>": "f.txt"}
-
-r"""usage: prog [--input=<file name>]..."""
-$ prog --input a.txt --input=b.txt
-{"--input": ["a.txt", "b.txt"]}
-
-#
-# Issue 85: `[options]` shourtcut with multiple subcommands
-#
-
-r"""usage: prog good [options]
-           prog fail [options]
-
-options: --loglevel=N
-
-"""
-$ prog fail --loglevel 5
-{"--loglevel": "5", "fail": true, "good": false}
-
-#
-# Usage-section syntax
-#
-
-r"""usage:prog --foo"""
-$ prog --foo
-{"--foo": true}
-
-r"""PROGRAM USAGE: prog --foo"""
-$ prog --foo
-{"--foo": true}
-
-r"""Usage: prog --foo
-           prog --bar
-NOT PART OF SECTION"""
-$ prog --foo
-{"--foo": true, "--bar": false}
-
-r"""Usage:
- prog --foo
- prog --bar
-
-NOT PART OF SECTION"""
-$ prog --foo
-{"--foo": true, "--bar": false}
-
-r"""Usage:
- prog --foo
- prog --bar
-NOT PART OF SECTION"""
-$ prog --foo
-{"--foo": true, "--bar": false}
-
-#
-# Options-section syntax
-#
-
-r"""Usage: prog [options]
-
-global options: --foo
-local options: --baz
-               --bar
-other options:
- --egg
- --spam
--not-an-option-
-
-"""
-$ prog --baz --egg
-{"--foo": false, "--baz": true, "--bar": false, "--egg": true, "--spam": false}
